# 一.链表

## 1.链表基本知识

![image-20211027220921831](.\images\链表结构.png)



![image-20211027220951250](.\images\链表介绍.png)

## 2.单向链表第一种实现

```c++
struct Node {
    Node(int data) : data(data),next(NULL){};
    int data;
    Node *next;
}

int main(){
    Node *head = NULL;
    head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    Node *p = head;
    while(p != NULL){
        printf("%d->",p->data);
        p = p->next
    }
    printf("\n");
    return 0;
}
```

## 3.单向链表第二中实现形式

```c++
int data[10];
int next[10];
void add(int ind,int p,int val){
    next[p] = next[ind];// 支持中间插入
    next[ind] = p;
    data[p] = val;
    return;
}
int main(){
    int head = 3;
    data[3] = 0;
    add(3,5,1);
    add(5,2,2);
    add(2,7,3);
    add(7,9,100);
    add(5,6,2);// 支持中间插入
    int p = head;
    while(p != 0){
        printf("%d->",data[p]);
        p = next[p];
    }
    printf("\n");
    return 0;
}
```

## 4.彩蛋课程

作业答案补充到url[彩蛋](https://xue.kaikeba.com/static/KKB000000.mp4)

## 5.场景

场景一：操作系统内的动态内存分配

![image-20211031231317110](.\images\链表的典型应用1.png)

场景二：LRU缓存淘汰算法

![image-20211031231935667](.\images\链表的典型应用2.png)

## 6.面试题-链表的访问

- 141.环形链表：给定一个链表，判断链表中是否有环。

  - 思路一：哈希表；总结起来就是，我们只需要遍历这个链表，在遍历的过程中记录我们遍历过的节点，如果遇到next节点为null的节点，说明没有环。如果遇到我们之前遍历过的节点，说明有环。

  - 思路二：快慢指针；如果链表有环，那么快慢指针一定会相遇，指向同一个节点，当指向同一个节点时，遍历结束

    ```c++
    bool hasCycle(ListNode *head){
        if(head == nullptr) return false;
        ListNode *p = head,*q = head->next;
        while(p != q && q && q->next){
            p = p->next;
            q = q->next->next;
        }
        return q && q->next;
    }
    ```


- 142环形链表Ⅱ：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

  ![](.\images\链表起点.png)

```c++
ListNode *detectCycle(ListNode *head){
	if(head == nullptr) return nullptr;
    ListNode *p = head,*q = head->next;
    while(p != q && q && q->next){
        p = p->next;
        q = q->next->next;
    }
    if(q == nullptr || q->next == nullptr) return nullptr;
    // 思考：可以把注释包裹的代码删除掉，我觉得应该是再判断if(head.next == nullptr) return 		nullptr;一个节点不可能成环，然后可直接初始化p、q为下面的值
    // 之所以初始化先走一步而不是都从head开始，因为判断条件要p和q不相等，都从head开始可以改为		do{}while{}
    p = head->next;q = head->next->next;
    while(p != q){
        p = p->next;
        q = q->next->next;
    }
    // 到这
    p = head;
    while(p != q){
        p = p->next;
        q = q->next;
    }
    return q;
}
```

```c++
// 上面思考的实现,想的没有错
ListNode *detectCycle(ListNode *head){
	if(head == nullptr) return nullptr;
    ListNode *p = head,*q = head;
    if(q->next == nullptr) return nullptr;
    do {
        p = p->next;
        q = q->next->next;
    }while(p != q && q && q->next);
    if(q == nullptr || q->next == nullptr) return nullptr;
    p = head;
    while(p != q){
        p = p->next;
        q = q->next;
    }
    return q;
}
```

- 202.快乐数

转换成环状链表，链表思维：唯一指向性

形参是整数类型，按各位平方相加，最大应该是1999999999=>730，所以链表最多7

30个节点

```c++
int getNext(int x){
    int z = 0;
    while(x){
        z += (x%10) * (x%10);
        x /= 10;
    }
    return z;
}
bool isHappy(int n){
    int p = n,q = n;
    do{
        p = getNext(p);
        q = getNext(getNext(q));
    }while(p != q && q!=1);
    return q == 1;
}
```

## 7.链表的反转

- 206.反转链表

![](.\images\反转链表init.png)

(1)定义指针——pre,pre指向空

定义指针——cur,cur指向我们的头节点

定义指针——next,next指向cur所指向节点的下一个节点，这样我们的指针就初始化完毕了

首先，我们将cur指针所指向的节点指向pre指针所指向的节点

然后移动指针pre到指针cur所在的位置，移动cur到next所在的位置，此时，我们已经反转了第一个节点

将我们的next指针指向cur指针所指向节点的下一个节点

然后重复上述操作

当cur指针指向null的时候，我们就完成了整个链表的反转

```c++
ListNode *reverseList(ListNode *head){
	if(head == nullptr) return head;
    ListNode *pre = nullptr,*cur = head,*p = head->next;
    while(cur){
        cur->next = pre;
        pre = cur;
        // 与逻辑，当cur指向空地址时不执行后面的赋值
        (cur = p) && (p = p->next);
    }
    return pre;
}
```

(2)基于递归的输出反转链表

递归的回复过程，相当于逆序的遍历链表，不影响原链表排序

```c++
void reverse(Node *p){
    if(p == NULL)return;
    reverse(p->next);
    printf("%d->",p->data);
    return;
}
```

基于这个思想，编写反转原链表

```c++
ListNode *reverseList(ListNode *head){
	if(head == nullptr || head->next == nullptr) return head;
    ListNode *tail = head-> next ,*p = reverseList(head->next);
    head->next = tail->next;
    tail->next = head;
    return p;
}
```

多传递一个数值，可控制反转头几个节点

```c++
ListNode *reverseN(ListNode *head,int n){
	if(n == 1) return head;
    ListNode *tail = head-> next ,*p = reverseN(head->next,n-1);
    head->next = tail->next;
    tail->next = head;
    return p;
}
```

- 92反转链表Ⅱ

反转从位置m到n的链表。请使用一趟扫描完成反转。

```c++
// 虚拟头节点：不需要判断是否是头一个节点
// 需要用到上面反转前n个节点的方法
ListNode* reverseBetween(ListNode* head,int m,int n){
    ListNode ret(0, head),*p = &ret;
    int cnt = n - m + 1;
    while(--m) p = p->next;
    p->next = reverseN(p->next,cnt);
    return ret.next;
}
```

- 25.K个一组反转链表

```c++
ListNode *__reverseN(ListNode *head,int n){
	if(n == 1) return head;
    ListNode *tail = head-> next ,*p = __reverseN(head->next,n-1);
    head->next = tail->next;
    tail->next = head;
    return p;
}
ListNode *reverseN(ListNode *head,int n){
    ListNode *p = head;
    int cnt = n;
    while(--n && p) p = p->next;
    if(p == nullptr)return head;
    return __reverseN(head,cnt);   
}
ListNode* reverseKGroup(ListNode* head, int k){
    ListNode ret(0,head),*p = &ret,*q = ret.next;
    while((p->next = reverseN(q,k)) != q){
        p = q;
        q = p->next;
    }  
    return ret.next;
}


```

- 61 旋转链表

把链表首尾相连，移动即可

```c++
ListNode *rotateRight(ListNode *head,int k){
    if(head == nullptr) return nullptr;
    int n = 1;
    ListNode *p = head;
    while(p->next) p = p->next,n += 1;
    p->next = head;
    k %= n;
    k = n - k;
    // k--是走到了head的前一位，即链表尾部
    while(k--) p = p->next;
    head = p->next;
    p->next = nullptr;
	return head;
}
```

## 8.链表的节点删除

- 19删除链表的倒数第N个结点

![](.\images\删除倒数N节点.png)

```c++
ListNode* removeNthFromEnd(ListNode* head,int n){
    ListNode ret(0,head), *p = &ret,*q = head;
    while(n--)q = q->next;
    while(q)p = p->next,q = q->next;
    p->next = p->next->next;
    return ret.next;
}
```

- 83.删除排序列表中的重复节点

```c++
ListNode* deleteDuplicates(ListNode* head){
	if(head == nullptr) return nullptr;
    ListNode *p = head;
    while(p->next){
        if(p->val == p->next->val){
            p->next = p->next->next;
        }else{
            p = p->next;
        }
    }
    return head;
}
```

- 82删除排序链表中的重复元素Ⅱ

```c++
ListNode* deleteDuplicates(ListNode* head){
    ListNode ret(0,head), *p = &ret, *q;
    while(p->next){
        if(p->next->next && p->next->val == p->next->next->val){
            q = p->next->next;
            while(q && q->val == p->next->val)q = q->next;
            p->next = q;
        }else{
            p = p->next;
        }
    }
    return ret.next;
}
```

什么时候用虚头：链表头地址有可能改变

# 二线程池与任务队列（Task-Queue）

## 1.队列基础知识

(1)标准队列：两个指针，一个头指针，一个尾指针，**尾指针指向最后一个节点的下一位**，头部出队，尾部入队，先入先出

(2)假溢出：其实还有位置可以放入其他元素，只是因为尾指针走到了最后一位，普通队列会误以为队列满了，为了解决假溢出，提出循环队列

(3)循环队列：走到尾部，再从头开始

![](.\images\循环队列.jpg)

(4)循环队列并不是特殊的队列，只是为了有效利用队列的空间，而提出的一种队列对假溢出的一种处理方式

## 2.几种经典的队列实现方法

(1)标准队列

```c++
class Quene{
    public:
    Quene(int n = 10): arr(n), head(0), tail(0){}
    void push(int x){
        if(full())return;
        arr[tail] = x;
        tail += 1;
        return;
    }// 入队
    void pop(){
        if(empty())return;
        head += 1;
        return;
    }// 出队
    // 为什么尾指针指向最后一个节点的下一位，源于各种语言描述一个区间的时候，采用左闭右开的区间描述方式，头尾指针标记的就是队列的区间，左闭右开还有个好处，tail-head等于当前元素的数量
    bool empty(){
        return head == tail;
    }// 判空
    bool full(){
        return tail == arr.size();
    }// 判满
    int front(){
        return arr[head];
    }// 查看队首元素
    int size(){
        return tail - head;
    }
    void output(){
        cout << "Queue : ";
        for(int i = head;i < tail,i++){
            cout << arr[i] << " ";
        }
        cout << endl;
        return;
    }
    private:
    int head,tail;
    // 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。
    vector<int> arr;
}
```

（2）循环队列

```c++
class Quene{
    public:
    Quene(int n = 10): arr(n), head(0), tail(0), cnt(0){}
    void push(int x){
        if(full())return;
        arr[tail] = x;
        tail += 1;
        cnt += 1;
        if(tail == arr.size())tail = 0;
        return;
    }// 入队
    void pop(){
        if(empty())return;
        head += 1;
        cut -= 1
        if(head == arr.size())head = 0;
        return;
    }// 出队
    bool empty(){
        return cnt == 0;
    }// 判空
    bool full(){
        return cnt == arr.size();
    }// 判满
    int front(){
        return arr[head];
    }// 查看队首元素
    int size(){
        return cnt;
    }
    void output(){
        cout << "Queue : ";
        for(int i = 0,j = head;i < cnt,i++){
            cout << arr[i] << " ";
            j += 1;
            if(j == arr.size()) j = 0;
        }
        cout << endl;
        return;
    }
    private:
    int head,tail;
    int cnt;// 当前队列的元素数量
    vector<int> arr;
}
```

## 3.队列的典型应用场景

(1)场景一：CPU的超线程技术

![](.\images\队列场景一.png)

(2)线程池的任务队列

![](.\images\队列场景二.png)

## 4.队列刷题

- 86.分隔链表

```c++
ListNode* partition(ListNode* head,int x){
	ListNode r1,r2,*p1 = &r1,*p2 = &r2,*p = head,*q;
    while(p){
        q = p->next;
        if(p->val < x){
            p->next = p1->next;
            p1->next = p;
            p1 = p;
        }else{
            p->next = p2->next;
            p2->next = p;
            p2 = p;
        }
        p = q;
    }
    p1->next = r2.next;
    return r1.next;
        
}
```

- 138.复制带随机指针的链表

```c++
Node* copyRandomList(Node* head){
    if(head == nullptr) return nullptr;
    Node *p = head,*q,*new_head;
    // 复制
    while(p){
        q = new Node(p->val);
        q->random = p->random;
        q->next = p->next;
        p->next = q;
        p = q->next;
    }
    // 修正random指针
    p = head->next;
    while(p){
        if(p->random) p->random = p->random->next;
        (p = p->next) && (p = p->next);
    }
    // 拆分成两个链表
    new_head = head->next;
    p = head;
    while(p){
        q = p->next;
        p->next = q->next;
        if(p->next) q->next = p->next->next;
        p = p->next;
    }
    return new_head;
}
```

## 5.队列的封装与使用

- 622.设计循环队列

```c++
class MyCircularQueue{
public:
    vector<int> arr;
    int head,tail,cnt;
    MyCircularQueue(int k) : arr(k), head(0), tail(0),cnt(0) {}
    
    bool enQueue(int value){
        if(isFull()) return false;
        arr[tail] = value;
        // 循环起来
        tail = (tail + 1) % arr.size();
        cnt += 1;
        return true;
    }
    
    bool deQueue(){
        if(isEmpty()) return false;
        head = (head + 1) % arr.size();
        cnt -= 1;
        return true;
    }
    
    int Front(){
        if(isEmpty()) return -1;
        return arr[head];
    }
    
    int Rear(){
        if(isEmpty()) return -1;
        // 处理负数的情况
        return arr[(tail - 1 + arr.size()) % arr.size()];
    }
    
    bool isEmpty(){
        return cnt == 0;
    }
    
    bool isFull(){
        return cnt == arr.size();
    }
};
```

- 641 设计双向循环队列

```c++
class MyCircularDeque {
public:
    vector<int> arr;
    int head,tail,cnt;
    MyCircularDeque(int k) : arr(k), head(0), tail(0),cnt(0) {}
    
    bool insertFront(int value) {
		if(isFull()) return false;
        // 循环起来
        head = (head - 1 + arr.size()) % arr.size();
        arr[head] = value;
        cnt += 1;
        return true;
    }
    
    bool insertLast(int value) {
		if(isFull()) return false;
        arr[tail] = value;
        // 循环起来
        tail = (tail + 1) % arr.size();
        cnt += 1;
        return true;
    }
    
    bool deleteFront() {
		if(isEmpty()) return false;
        head = (head + 1) % arr.size();
        cnt -= 1;
        return true;
    }
    
    bool deleteLast() {
		if(isEmpty()) return false;
        tail = (tail - 1 + arr.size()) % arr.size();
        cnt -= 1;
        return true;
    }
    
    int getFront() {
		if(isEmpty()) return -1;
        return arr[head];
    }
    
    int getRear() {
		if(isEmpty()) return -1;
        // 处理负数的情况
        return arr[(tail - 1 + arr.size()) % arr.size()];
    }
    
    bool isEmpty(){
        return cnt == 0;
    }
    
    bool isFull(){
        return cnt == arr.size();
    }
};
```

- 1670 设计前中后队列

```c++
// 先实现一个链表结构的双端队列
class Node {
public:
    int val;
    Node *next, *pre;
    Node(int val = 0, Node *next = nullptr,Node *pre = nullptr) : val(val), next(next),pre(pre){}
    void insert_pre(Node *p){
        p->pre = pre;
        p->next = this;
        if(this->pre) this->pre->next = p;
        this->pre = p;
        return;
    }
    void insert_next(Node *p){
        p->pre = this;
        p->next = this->next;
        if(this->next) this->next->pre = p;
        this->next = p;
        return;
    }
    void delete_pre(){
       if(this->pre == nullptr) return;
        Node *p = this->pre;
        this->pre = p->pre;
        if(p->pre) p->pre->next = this;
        delete p;
        return;
    }
    void delete_next(){
       if(this->next == nullptr) return;
        Node *p = this->next;
        this->next = p->next;
        if(p->next) p->next->pre = this;
        delete p;
        return;
    }
};
class Queue{
public:	
    // 虚拟头、尾
    Node head,tail;
    int cnt;
    Queue() : cnt(0) {
        head.next = &tail;
        head.pre = nullptr;
        tail.next = nullptr;
        tail.pre = &head;
    }
    void push_back(int val){
        tail.insert_pre(new Node(val));
        cnt +=1;
        return;
    }
    void push_front(int val){
        head.insert_next(new Node(val));
        cnt +=1;
        return;
    }
    int pop_back(){
        if(isEmpty()) return -1;
        int ret = tail.pre->val;
        tail.delete_pre();
        cnt -=1;
        return ret;
    }
    int pop_front(){
        if(isEmpty()) return -1;
        int ret = head.next->val;
        head.delete_next();
        cnt -=1;
        return ret;
    }
    int front(){
        return head.next->val;
    }
    int back(){
        return tail.pre->val;
    }
    bool isEmpty(){
        return head.next == &tail;
    }
    int size(){
        return cnt;
    }
};
```



```c++
class FrontMiddleBackQueue {
public:
    Queue q1,q2;
    FrontMiddleBackQueue() {}
    
    void pushFront(int val) {
		q1.push_front(val);
        update();
        return;
    }
    
    void pushMiddle(int val) {
        // 奇数时1,3,2 插入到3前面，所以先移动
		if(q1.size() > q2.size()){
            q2.push_front(q1.back());
            q1.pop_back();
        }
        q1.push_back(val);
        return;
    }
    
    void pushBack(int val) {
		q2.push_back(val);
        update();
        return;
    }
    
    int popFront() {
		if(isEmpty()) return -1;
        int ret = q1.pop_front();
        update();
        return ret;
    }
    
    int popMiddle() {
        // 奇数偶数都是移除p1末尾元素
		if(isEmpty()) return -1;
        int ret = q1.pop_back();
        update();
        return ret;
    }
    
    int popBack() {
		if(isEmpty()) return -1;
        int ret; 
        if(q2.isEmpty()){
        	ret = q1.pop_back();
        }else{
            ret = q2.pop_back();
        }
        update();
        return ret;
    }
    bool isEmpty(){
        // 因为q1总比q2长，q1为空，q2也一定为空
        return q1.size() == 0;
    }
    void update(){
        if(q1.size() < q2.size()){
            q1.push_back(q2.front());
            q2.pop_front();
        }
        if(q1.size() == q2.size() + 2){
            q2.push_front(q1.back());
            q1.pop_back();
        }
        return;
    }
};
```

- 933最近请求次数

```c++
class RecentCounter{
public:
	queue<int> q;
    RecentCounter(){}
    
    int ping (int t){
        q.push(t);
        while(t - p.front() > 3000) p.pop();
        return q.size();
    }
}
```

## 6.经典面试题-智力发散题

- 17.09第k个数

```c++
class Solution {
public:
    int getKthMagicNumber(int k) {
		vector<int> arr;
        arr.push_back(1);
        int p3 = 0,p5 = 0,p7 = 0;
         while(arr.size() < k){
            int ans = 3 * arr[p3];
            ans = min(ans, 5 * arr[p5]);
            ans = min(ans, 7 * arr[p7]);
            if(ans == 3 * arr[p3]) p3++;
            if(ans == 5 * arr[p5]) p5++;
            if(ans == 7 * arr[p7]) p7++;
            arr.push_back(ans);
        }
        return arr[k-1];
    }
};
```

- 859.亲密字符串

```c++
class Solution {
public:
    bool has_repeate(string a){
        int cnt[26] = {0};
        for(int i = 0; a[i]; i++){
            cnt[a[i] - 'a'] += 1;
            if(cnt[a[i] - 'a'] == 2) return true;
        }
        return false;
    }
    bool buddyStrings(string a, string b) {
		if(a.size() != b.size()) return false;
        // 这里自己写的时候错了，特殊情况下重复返回true
        //if(a == b && !has_repeate(a)) return false;
        if(a == b) return has_repeate(a);
        int i = 0,j;
        while(a[i] == b[i]) ++i;
        j = i+1;
        while(j < a.size() && a[j] == b[j]) ++j;
        if(j == a.size()) return false;
        if(a[i] != b[j] || a[j] != b[i]) return false;
        j += 1;
        while(j < a.size()){
            if(a[j] != b[j]) return false;
            j += 1;
        }
        return true;
    }
};
```

- 860柠檬水找零

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
		int cnt5 = 0, cnt10 = 0;
        for(int i = 0; i<bills.size(); i++){
            switch(bills[i]){
                case 5:cnt5 += 1;break;
                case 10: {
                    if(cnt5 == 0)return false;
                    cnt5 -=1; cnt10 +=1;
                } break;
                case 20: {
                    if(cnt10 && cnt5){
                        cnt10 -= 1;cnt5 -= 1;
                    }else if(cnt5 >= 3){
                        cnt5 -= 3;
                    }else{
                        return false;
                    }
                }break;
            }
        }
        return true;
    }
};
```

- 969.煎饼排序

```c++
class Solution {
public:
    void reverse(vector<int> &arr, int n, vector<int> &ind){
        for(int i = 0,j = n - 1; i < j; i++,j--){
            swap(arr[i], arr[j]);
            // arr已经反转，把变化的位置重新赋一下ind既可
            ind[arr[i]] = i;
            ind[arr[j]] = j;
        }
        return;
    }
    vector<int> pancakeSort(vector<int>& arr) {
		vector<int> ind(arr.size() + 1);
        vector<int> ret;
        for(int i = 0; i < arr.size(); i++) ind[arr[i]] = i;
        for(int i = arr.size(); i >= 1; i--){
            if(ind[i] == i - 1) continue;
            if(ind[i] + 1 != 1){
                ret.push_back(ind[i] + 1);
                reverse(arr, ind[i] + 1, ind);
            }
            if(i != 1){
                ret.push_back(i);
                reverse(arr, i, ind);
            }  
        }
        return ret;
    }
};
```

- 621任务调度

![](.\images\621任务调度.jpg)

```c++
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
		int cnt[26] = {0};
        for(int i = 0; i < tasks.size(); i++) cnt[tasks[i] - 'A'] += 1;
        sort(cnt, cnt + 26);
        int m = 0;
        // 求有几个元素是最大值
        for(int i = 25; i > 0 && cnt[i] == cnt[25]; i--, m++);
        return max((int)tasks.size(), (cnt[25] - 1) * (n + 1) + m);
    }
};
```

# 三.栈

## 1.基础知识

(1)基本操作：出栈入栈

(2)先入后出，后入先出

## 2.栈适合解决什么问题

(1)括号匹配

结论：①在任意一个位置上，左括号数量>=右括号数量

②在最后一个位置上，左括号数量==右括号数量

③程序中只需要记录左括号数量和右括号数量即可

v1

![](.\images\括号匹配v1.png)

v2

<img src=".\images\括号匹配v2.png" style="zoom:67%;" />

### 括号匹配思考

![](.\images\括号匹配思考.png)

得出：栈可以处理具有完全包含关系的问题

## 3.经典的栈实现方法

```c++
// 用vector实现的
class Stack{
public:
    Stack(){}
    void push(int x){
        data.push_back(x);
        return;
    }
    void pop(){
        if(empty()) return;
        data.pop_back(x);
        return;
    }
    bool empty(){
        return data.size() == 0;
    }
    int size(){
        return data.size();
    }
    void output(){
        cout << "======" << endl;
        for(int i = data.size() - 1; i >= 0; i--){
            cout << "  " << data[i] << endl;
        }
        cout << "======" << endl;
        return;
    }
private:
    vector<int> data;
}
```

```c++
// 用普通数组实现
class Stack{
public:
    Stack(int n = 100){
        top = -1;
        data = new int[n]
    }
    void push(int x){
        top += 1;
        data[top] = x;
        return;
    }
    void pop(){
        if(empty()) return;
        top -= 1;
        return;
    }
    bool empty(){
        return top == -1;;
    }
    int size(){
        return top + 1;
    }
    void output(){
        cout << "======" << endl;
        for(int i = top; i >= 0; i--){
            cout << "  " << data[i] << endl;
        }
        cout << "======" << endl;
        return;
    }
private:
    int *data, top;
}
```

## 4.栈的典型应用场景

1.栈应用场景一

![](.\images\栈应用场景一.jpg)

爆栈

![](.\images\爆栈.png)

2.栈应用场景二

是什么表达式取决于最后一个运算符，为了找到最后一个运算符，所以给运算符人为设定数值上的优先级，括号内的加100

![](.\images\栈应用场景二.png)

```c++
int calc(char *s, int l, int r){
    // 最小优先级的位置，最小优先级的大小，当前运算符优先级，控制出现'('、')'优先级
    int op = -1,pri = 10000 - 1, cur_pri, temp = 0;
    for(int i = l;i <= r; i++){
        cur_pri = 10000;
        switch (s[i]) {
            case '+':
            case '-': cur_pri = 1 + temp;break;
            case '*':
            case '/': cur_pri = 2 + temp;break;
            case '(': temp += 100; break;
            case ')': temp -= 100; break;
        }
        if(cur_pri <= pri){
            pri = cur_pri;
            op = i;
        }
    }
    // 说明表达式没有运算符
    if(op == -1){
        int num = 0;
        for(int i = l, i <= r; i++){
            if(s[i] < '0' || s[i] > '9') continue;
            num = num * 10 + (s[i] - '0');
        }
        return num;
    }
    int a = calc(s, l, op - 1);
    int b = calc(s, op + 1, r);
    switch (s[op]) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
    }
    return 0;
}
int main(){
    char s[100];
    while(~scanf("%[^\n]s", s)){ // 读入表达式
        getchar();
        printf("%s = %d\n", s, calc(s, 0, strlen(s) - 1));
    }
    return 0;
}
```

## 5.经典面试题-栈的基本操作

- 03.04化栈为队

```c++
s2入队〇〇〇|①②③
s1出队①②③|〇〇〇
s1出队②③|〇〇〇
s2入队②③|④⑤⑥
class MyQueue {
public:
    stack<int> s1,s2;
    /** Initialize your data structure here. */
    MyQueue() {}
    
    /** Push element x to the back of queue. */
    void push(int x) {
		s2.push(x);
        return;
    }
    
    void transfer(){
        if(!s1.empty()) return;
        while(!s2.empty()){
            s1.push(s2.top());
            s2.pop();
        }
        return;
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
		transfer();
        int ret = s1.top();
        s1.pop();
        return ret;
    }
    
    /** Get the front element. */
    int peek() {
		transfer();
        return s1.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
		return s1.empty() && s2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

- 682棒球比赛

```c++
class Solution {
public:
    stack<int> s;
    int calPoints(vector<string>& ops) {
		for(int i = 0; i < ops.size(); i++){
            if(ops[i] == "+"){
                int a = s.top();s.pop();
                int b = s.top();
                s.push(a), s.push(a + b);
            }else if(ops[i] == "D"){
                s.push(s.top() * 2);
            }else if(ops[i] == "C"){
                s.pop();
            }else{
                s.push(atoi(ops[i].c_str()));// 把字符串转化为数字
            }
        }
        int sum = 0;
        while(!s.empty()){
            sum += s.top();
            s.pop();
        }
        return sum;
    }
};
```

- 844.比较含退格的字符串

```c++
class Solution {
public:
    void transform(string S, stack<char> &s){
        for(int i = 0; i < S.size(); i++){
            if(S[i] == '#' && !s.empty()) s.pop();
            else if(S[i] != '#') s.push(S[i]);
        }
        return ;
    }
    bool backspaceCompare(string S, string T) {
		stack<char> s;
		stack<char> t;
        transform(S, s);
        transform(T, t);
        if(s.size() - t.size()) return false;
        while(!s.empty()){
            if(s.top() != t.top()) return false;
            s.pop(), t.pop();
        }
        return true;
    }
};
```

- 946.验证栈序列

只需关注出栈序列poppe即可，符合只有两种情况

①当前栈顶元素和要出栈元素相等

②未来有可能入栈

![](.\images\946.png)

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
		stack<int> s;
        for(int i = 0, j = 0; i < popped.size(); i++){
            while(j < pushed.size() && (s.empty() || s.top() != popped[i])){
                s.push(pushed[j]);
                j += 1;
            }
            if(s.top() != popped[i]) return false;
            s.pop();
        }
        return true;
    }
};
```

## 6.经典面试题-栈结构扩展

20.有效括号

```c++
class Solution {
public:
    bool isValid(string s) {
		stack<char> ss;
        for(int i = 0; i < s.size(); i++){
            switch(s[i]){
                case '(':
                case '[':
                case '{': ss.push(s[i]);break;
                case ')': if(ss.empty() || ss.top() != '(') return false; ss.pop(); break;
                case ']': if(ss.empty() || ss.top() != '[') return false; ss.pop(); break;
                case '}': if(ss.empty() || ss.top() != '{') return false; ss.pop(); break;
            }
        }
    	return ss.empty();
    }
};
```

- 1021删除最外层的括号

````c++
class Solution {
public:
    string removeOuterParentheses(string s) {
		string ret;
        // pre记录每一段独立括号的初始位置，cnt记录差值
        for(int i = 0, pre = 0, cnt = 0; i < s.size(); i++){
            if(s[i] == '(') cnt += 1;
            else cnt -= 1;
            if(cnt != 0)continue;
            ret += s.substr(pre + 1,i - pre - 1);
            pre = i + 1;
        }
        return ret;


````

- 1249移除无效的括号

 ```c++  
// 用栈的方式实现
class Solution {
public:
  string minRemoveToMakeValid(string s) {
	set<int> del;
      stack<int> ss;
      for(int i = 0; i < s.size(); i++){
          // 跳过多余元素
          if(s[i] - '(' && s[i] - ')') continue;
          if(s[i] == '(') ss.push(i);
          else{
              if(ss.empty()) del.insert(i);
              else ss.pop();
          }
      }
      // 多余的(
      while(!ss.empty()) del.insert(ss.top()), ss.pop();
      string ret;
      for(int i = 0; i < s.size(); i++){
          // set::find是C++ STL中的内置函数，该函数将迭代器返回到在集合容器中搜索的元素。如果找不到该元素，则迭代器将指向集合中最后一个元素之后的位置。
          if(del.find(i) != del.end()) continue;
          ret += s[i];
      }
      return ret;
  }
};
 ```

```c++
// 不用栈实现，先从前向后遍历，跳过多余的右括号，再从后向前遍历，跳过多余的左括号。
```

- 145二叉树的后序遍历

```c++
// 用迭代的方式去实现，模拟系统栈，还额外需要一个状态栈，记录程序需要做哪一步
// 规定 0 -> 放入左子树、1 -> 放入右子树、2 -> 输出根节点
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
		if (root == nullptr) return vector<int>();
        vector<int> ans;
        stack<TreeNode *> s1; // 递归过程中的局部变量
        stack<int> s2;
        s1.push(root);
        s2.push(0);
        while(!s1.empty()){
            int status = s2.top();
            s2.pop();
            switch (status) {
                case 0: {
                    s2.push(1);
                    if(s1.top()->left != nullptr){
                        s1.push(s1.top()->left);
                        s2.push(0);
                    }
                }break;
                case 1: {
                    s2.push(2);
                    if(s1.top()->right != nullptr){
                        s1.push(s1.top()->right);
                        s2.push(0);
                    }
                }break; 
                case 2: {
                    ans.push_back(s1.top()->val);
                    s1.pop();
                }break; 
            }
        }
        return ans;
    }
};
```

- 331验证二叉树的前序序列化

![](.\images\331.png)

```c++
class Solution {
public:
    bool isValidSerialization(string preorder) {
		vector<string> s;
        for(int i = 0, j = 0; i < preorder.size(); i = j + 1){
            // 下面3行是c++在处理逗号，每次j需要从i开始找逗号
			j = i;
            while(j < preorder.size() && preorder[j] != ',') ++j;
            s.push_back(preorder.substr(i, j - i));
            int last = s.size() - 1;
            while(s.size() >= 3 && s[last] == "#" && s[last - 1] == "#" && s[last - 2] != "#"){
                s[last - 2] = "#";
                s.pop_back();
                s.pop_back();
                // 重新定位最后一位元素
                last = s.size() - 1;
            }
        }
        return s.size() == 1 && s[0] == "#";
    }
};
```

- 227.基本计数器Ⅱ

```c++
// 用双栈依次把操作数和运算符依次压入栈中，然后当当前压入的运算符优先级小于栈顶元素运算符优先级时，得把前面运算符得运算结果先计算了
class Solution {
public:
    int level(char c){
        switch(c){
            case '@': return -1;
            case '+':
            case '-': return 1;
            case '*':
            case '/': return 2;
        }
        return 0;
    }
    int calc(int a, char op, int b){
        switch(op){
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b; 
        }
        return 0;
    }
    int calculate(string s) {
		stack<int> num;
		stack<char> ops;
        // 因为代码逻辑是碰到低优先级运算符就会计算前面的，所以多加一个优先级最低的符号执行最后的计算
        s += "@";
        for(int i = 0, n = 0; i < s.size(); i++){
            if(s[i] == ' ')continue;
            if(level(s[i]) == 0){
                n = n * 10 + (s[i] - '0');
                continue;
            }
            num.push(n);
            n = 0;
            while(!ops.empty() && level(s[i]) <= level(ops.top())){
                int b = num.top(); num.pop();
                int a = num.top(); num.pop();
                num.push(calc(a, ops.top(), b));
                ops.pop();
            }
            ops.push(s[i]);
        }
        return num.top();
    }
};
```

- 636函数的独占时间

```c++
class Solution {
public:
    vector<int> exclusiveTime(int n, vector<string>& logs) {
		vector<int> ans(n);
        stack<int> vID;
        for(int i = 0, pre = 0; i < logs.size(); i++){
            int pos1 = logs[i].find_first_of(":");
            int pos2 = logs[i].find_last_of(":");
            string id_str = logs[i].substr(0, pos1);
            string status = logs[i].substr(pos1 + 1, pos2 - pos1 - 1);
            string time_str = logs[i].substr(pos2 + 1, logs[i].size());
            int id = atoi(id_str.c_str());
            int time_stamp = atoi(time_str.c_str());
            if(!vID.empty()) ans[vID.top()] += time_stamp - pre + (status == "end");
            pre = time_stamp + (status == "end");
            if(status == "start") vID.push(id);
            else vID.pop();
            /*
            if(status == "start"){
                if(!vID.empty()){
                    ans[vID.top()] += time_stamp - pre;
                }
                pre = time_stamp;
                vID.push(id);
            }else{
                ans[vID.top()] += time_stamp - pre + 1;
                pre = time_stamp + 1;
                vID.pop();
            } 
            */
        }
        return ans;
    }
};
```

- 1124.表现良好的最长时间段

编程技巧前缀和数组：把前i项相加之和得到的结果组成数组；好处：可以帮助我们快速的计算原序列的区间和

![](.\images\1124.png)

```c++
class Solution {
public:
    int longestWPI(vector<int>& hours) {
        // 前缀和中每一个值第一次出现的位置
		unordered_map<int, int> ind;
        // 记录每个值的第一次出现时最长长度，因为初始值是0，所以负数会被置为0
		unordered_map<int, int> f;
        ind[0] = -1;
        f[0] = 0;
        // cnt前缀和
        int cnt = 0, ans = 0;
        for(int i = 0; i < hours.size(); i++){
            if(hours[i] > 8) cnt += 1;
            else cnt -= 1;
            if(ind.find(cnt) == ind.end()){
                ind[cnt] = i;
                if(ind.find(cnt - 1) == ind.end()) f[cnt] = 0;
                else f[cnt] = f[cnt - 1] + (i - ind[cnt - 1]);
            }
            if(ind.find(cnt - 1) == ind.end()) continue;
            ans = max(ans, i - ind[cnt - 1] + f[cnt - 1]);
        }
        return ans;
    }
};
```

# 四.二叉树

## 1.基本知识

![](.\images\树结构定义.png)

![](.\images\二叉树.png)

说明：几度就是有几个孩子

![](.\images\前序遍历.png)

![](.\images\中序遍历.png)

![](.\images\后序遍历.png)

中+前/后 可以还原一颗二叉树

![](.\images\还原二叉树.png)

完全二叉树：在最后一层的右侧缺少节点的二叉树

满二叉树：没有度为1的节点

完美二叉树：每一层都满了的二叉树

![](.\images\二叉树正确版.jpg)

**完全二叉树**（有价值）

![](.\images\完全二叉树.jpg)

关于树结构的深入理解

树的节点代表集合，树的边代表关系，可以总结出父节点和子节点间的关系，父节点代表全集，子节点代表父节点互不相交的子集。

集合涉及到的问题最核心之一是查找，所以树结构最主要的作用就是应用于各种场景下的查找操作

## 2.学习二叉树的作用

(1)二叉树的作用一

![](.\images\二叉树的作用一.png)

(2).二叉树的作用二

![](.\images\二叉树的作用二.png)

二叉树的作用二举例.png

![](.\images\二叉树的作用二举例.png)

(3).二叉树的作用三

<img src=".\images\左孩子右兄弟.png" style="zoom:50%;" />

![](.\images\二叉树作用三.png)

## 3.经典面试题-二叉树的基本操作

- 144二叉树的前序遍历

```c++
class Solution {
public:
    void preorder(TreeNode *root,vector<int> &ans){
        if(root == NULL)return;
        ans.push_back(root->val);
        preorder(root->left, ans);
        preorder(root->right, ans);
        return;
    }
    vector<int> preorderTraversal(TreeNode* root) {
		vector<int> ans;
        preorder(root, ans);
        return ans;
    }
};
```

- 589 N叉树的前序遍历

```c++
class Solution {
public:
    void __preorder(Node *root,vector<int> &ans){
        if(root == NULL)return;
        ans.push_back(root->val);
        for(auto x : root->children){
        	__preorder(x, ans);
        }
        return;
    }
    vector<int> preorder(Node* root) {
		vector<int> ans;
        __preorder(root, ans);
        return ans;
    }
};
```

- 226翻转二叉树

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
		if(root == NULL) return root;
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

- 剑指offer32.从上到下打印二叉树Ⅱ

```c++
class Solution {
public:
    void getResult(TreeNode *root, int k, vector<vector<int>> &ans){
        if(root == NULL) return;
        if(k == ans.size()) ans.push_back(vector<int>());
        ans[k].push_back(root->val);
        getResult(root->left, k + 1, ans);
        getResult(root->right, k + 1, ans);
        return;
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
		vector<vector<int>> ans;
        getResult(root, 0, ans);
        return ans;
    }
};
```

=========================================================================

- 222.完全二叉树的节点个数

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
		if(root == NULL) return 0;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

- 剑指 Offer 54. 二叉搜索树的第k大节点

二叉搜索树：右子树上的值都要大于根节点，左子树上的值都要小于根节点。

特点：中序遍历的结果就是一个有序序列

```c++
class Solution {
public:
    int getCount(TreeNode *root) {
		if(root == NULL) return 0;
        return getCount(root->left) + getCount(root->right) + 1;
    }
    int kthLargest(TreeNode* root, int k) {
		int cnt_r = getCount(root->right);
        if(k <= cnt_r) return kthLargest(root->right, k);
        if(k == cnt_r + 1) return root->val;
        return kthLargest(root->left, k - cnt_r - 1);
    }
};
```

```c++
// 简单实现中序遍历后找第k大
class Solution {
public:
    void in_order(TreeNode *root, vector<int> &ans) {
		if(root == NULL) return;
        in_order(root->left, ans);
        ans.push_back(root->val);
        in_order(root->right, ans); 
        return;
    }
    int kthLargest(TreeNode* root, int k) {
		vector<int> ans;
        in_order(root, ans);
        return ans[ans.size() - k];
    }
};
```

- 剑指 Offer 26. 树的子结构

```c++
class Solution {
public:
    bool is_Match(TreeNode *A, TreeNode *B){
        // 走到B为空说明B至少是A的一部分
        if(B == NULL)return true;
        // B不为空A为空false
        if(A == NULL)return false;
        if(A->val != B->val)return false;
        return is_Match(A->left, B->left) && is_Match(A->right, B->right);
    }
    bool isSubStructure(TreeNode* A, TreeNode* B) {
		if(B == NULL) return false;
		if(A == NULL) return false;
        if(A->val == B->val && is_Match(A, B)) return true;
        return isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
};
```

- 662.二叉树最大宽度



```c++
class Solution {
public:
    typedef pair<TreeNode *, int> PNI;
    int widthOfBinaryTree(TreeNode* root) {
        int ans = 0;
        // 用队列处理每一行数据
		queue<PNI> q;
        q.push(PNI(root, 0));
        while(!q.empty()){
            int cnt = q.size();
            // l为当前行最小编号，r为最大编号
            int l = q.front().second, r = q.front().second;
            for(int i = 0; i < cnt; i++){
                TreeNode *n = q.front().first;
                int ind = q.front().second;
                r = ind;
                // 运用了完美二叉树的编号技巧
                // 节点编号为（父节点-父所在行最小编号）*2，以后看不懂看视频多看
                if(n->left) q.push(PNI(n->left, (ind - l)*2));
                if(n->right) q.push(PNI(n->right, (ind - l)*2 + 1));
                q.pop();
            }
            ans = max(ans, r - l +1);
        }
        return ans;
    }
};
```

![](.\images\662.jpg)

- 968.监控二叉树

```c++
class Solution {
public:
    void getDP(TreeNode *root, int dp[2][2]){
        if(root == NULL){
            dp[0][0] = 0;
            dp[0][1] = 10000;
            dp[1][0] = 0;
            dp[1][1] = 10000;
            return;
        }
        if(root->left == NULL && root->right == NULL){
            dp[0][0] = 10000;
            dp[0][1] = 1;
            dp[1][0] = 0;
            dp[1][1] = 1;
            return;
        }
        int l[2][2], r[2][2];
        getDP(root->left, l);
        getDP(root->right, r);
        dp[0][0] = min(min(l[0][1] + r[0][0] ,l[0][0] + r[0][1]), l[0][1] + r[0][1]);
        dp[1][0] = min(dp[0][0], l[0][0] + r[0][0]);
        dp[0][1] = min(min(l[1][0] + r[1][0] ,l[1][1] + r[1][1]), min(l[1][0] + r[1][1] ,l[1][1] + r[1][0])) + 1;
        dp[1][1] = dp[0][1];
        
    }
    int minCameraCover(TreeNode* root) {
		int dp[2][2];
        getDP(root, dp);
        return min(dp[0][1], dp[0][0]);
    }
};
```

# 五.堆与优先队列

## 1.堆的基础知识

(1)**数据结构**：**结构定义**（结构（基于完全二叉树）+结构性质（大顶堆、小顶堆）） + **结构操作**（维护这种结构性质），**总结数据结构就是定义一种性质，并且维护这种性质**

(2)大顶堆：任意的一个三元组之间，父节点都要大于两个子节点

(3)结构操作

①尾部插入调整：先在末尾插入，再向上调整

②头部弹出调整：弹出头部元素，把尾部元素放入头部，再向下调整

③堆排序

口诀

- 将堆顶元素与堆尾元素交换
- 将此操作看作是堆顶元素弹出操作
- 按照头部弹出以后的策略调整堆
- 执行n次

(4)优先队列

堆是优先队列的一种实现方式

![](.\images\优先队列.png)

## 2.堆的代码实现

```c++
#define Max_N 1000
int data[Max_N + 5], cnt = 0;

int top(){ return data[0];}
int size(){ return cnt;}

void push(int x){
    data[cnt++] = x;
    int ind = cnt - 1;
    // 左右节点获取父节点的下标都是(ind - 1) / 2
    while(ind && data[(ind - 1) / 2] < data[ind]){
        swap(data[(ind - 1) / 2], data[ind]);
        ind = (ind - 1) / 2;
    }
    return;
}
void pop(){
    if(size() == 0) return;
    data[0] = data[cnt - 1];
    cnt -= 1;
    int ind = 0; n = cnt - 1;
    while(ind * 2 + 1 <= n){
        int temp = ind;
        if(data[temp] < data[ind * 2 + 1]) temp = ind * 2 + 1;
        if(ind * 2 + 2 <= n && data[temp] < data[ind * 2 + 2]) temp = ind * 2 + 2;
        if(temp == ind)break;
        swap(data[temp], data[ind]);
        ind = temp;
    }
    
}
```

```c++
// 实现的漂亮点
#define Max_N 1000
int data[Max_N + 5], cnt = 0;

int top(){ return data[0];}
int size(){ return cnt;}

void shift_up(int ind){
    // 左右节点获取父节点的下标都是(ind - 1) / 2
    while(ind && data[(ind - 1) / 2] < data[ind]){
        swap(data[(ind - 1) / 2], data[ind]);
        ind = (ind - 1) / 2;
    }
    return;
}

void shift_down(int ind){
    int n = cnt -1;
    while(ind * 2 + 1 <= n){
        int temp = ind;
        if(data[temp] < data[ind * 2 + 1]) temp = ind * 2 + 1;
        if(ind * 2 + 2 <= n && data[temp] < data[ind * 2 + 2]) temp = ind * 2 + 2;
        if(temp == ind)break;
        swap(data[temp], data[ind]);
        ind = temp;
    }
    return;
}

void push(int x){
    data[cnt++] = x;
    shift_up(cnt - 1);
    return;
}
void pop(){
    if(size() == 0) return;
    // 排序，赋值改成交换
    swap(data[0], data[cnt - 1]);
    cnt -= 1;
    shift_down(0);
    return;
}

void output(int n){
    printf("heap : ");
    for(int i = 0; i < n; i++){
        printf("%d ", data[i]);
    }
    printf("\n");
    return;
}

int main(){
    int op, val;
    // 记录最大树节点数量，查看堆排序结果
    int max_n = 0;
    while(cin >> op){
        switch(op){
            case 0:{
                cin >> val;
                printf("push %d to heap\n", val);
                push(val);
            }break;
            case 1:{
                printf("push %d to heap\n", top());
                pop();
            }break;
            case 2:{
                // 输出堆排序后data中中的值
                output(max_n);
            }break;
        }
        max_n = max(cnt, max_n);
    	output(cnt);
    }
    return 0;
}
```

## 3.经典面试题-堆的基础应用

一句话理解：堆

堆适合维护：集合最值

- 剑指 Offer 40. 最小的k个数

```c++
class Solution {
public:
    // 用c++的语法实现了一个堆，传less<int>()代表大顶堆，传greater<int>()代表小顶堆
    template<typename T>
    class Heap: public vector<T>{
    public:
        template<typename Func_T>
        Heap(Func_T cmp) : cmp(cmp) {}
        void push(const T &a){
            this->push_back(a);
            push_heap(this->begin(), this->end(), cmp);
            return;
        }
        void pop(){
            pop_heap(this->begin(), this->end(), cmp);
            this->pop_back();
            return;
        }
        T &top() {return this->at(0);}
    private:
        function<bool(T, T)> cmp;
    };
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
		Heap<int> h{less<int>()};
        for(auto x : arr){
            h.push(x);
            if(h.size() > k)h.pop();
        }
        return h;
    }
};
```

- 1046.最后一块石头的重量

```c++
class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
		Heap<int> h{less<int>()};
        for(auto x : stones){
            h.push(x);
        }
        while(h.size() > 1){
            int y = h.top(); h.pop();
            int x = h.top(); h.pop();
            if(x == y) continue;
            h.push(y - x);
        }
        if(h.size() == 0) return 0;
        return h.top();
    }
};
```

- 703.数据流中的第 K 大元素

```c++
class KthLargest {
public:
    Heap<int> h{greater<int>()};
    int k;
    KthLargest(int k, vector<int>& nums) : k(k) {
		for(auto x : nums){
            add(x);
        }
        return;
    }
    
    int add(int val) {
		h.push(val);
        if(h.size() > k) h.pop();
        return h.top();
    }
};

```

- 215.数组中的第K个最大元素

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
		Heap<int> h{greater<int>()};
        for(auto x : nums){
            h.push(x);
            if(h.size() > k)h.pop();
        }
        return h.top();
    }
};
```

- 373.查找和最小的K对数字

```c++
class Solution {
public:
    struct CMP{
        bool operator()(vector<int> a, vector<int> b){
            return a[0] + a[1] < b[0] + b[1];
        }
    }
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        // 创造了一个大顶堆
        CMP less_than;
		Heap<vector<int>> h{less_than};
        vector<int> temp(2);
        for(auto x : nums1){
        	for(auto y : nums2){
                temp[0] = x, temp[1] = y;
                // 长度小于k前直接放入
                if(h.size() < k || less_than(temp, h.top())){
                	h.push(temp);
            		if(h.size() > k) h.pop(); 
                }else{
                    break;
                }	
        	}  
        }
        return h;    
    }
};
```

- 692.前K个高频单词

```c++
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
		unordered_map<string, int>freq;
        for(auto x : words) freq[x] += 1;
        auto cmp = [&freq](string a, string b) -> bool {
            if(freq[a] - freq[b]) return freq[a] > freq[b];
            return a < b;
        };
        Heap<string> h{cmp};
        for(auto x : freq){
            h.push(x.first);
            if(h.size() >k) h.pop();
        }
        sort(h.begin(), h.end(), cmp);
        return h;
    }
};
```

- 295.数据流的中位数 / 面试题 17.20. 连续中值

![](.\images\295.jpg)

```c++
class MedianFinder {
public:
    template<typename T>
    class Heap: public vector<T>{
    public:
        template<typename Func_T>
        Heap(Func_T cmp) : cmp(cmp) {}
        void push(const T &a){
            this->push_back(a);
            push_heap(this->begin(), this->end(), cmp);
            return;
        }
        T pop(){
            T ret = top();
            pop_heap(this->begin(), this->end(), cmp);
            this->pop_back();
            return ret;
        }
        T &top() {return this->at(0);}
    private:
        function<bool(T, T)> cmp;
    };
    Heap<int> h1, h2;
    MedianFinder() : h1{less<int>()}, h2{greater<int>()}{}
    
    void addNum(int num) {
		if(h1.size() == 0 || num <= h1.top()){
            h1.push(num);
        }else{
            h2.push(num);
        }
        if(h2.size() > h1.size()){
            h1.push(h2.pop());
        }
        if(h1.size() == h2.size() + 2){
            h2.push(h1.pop());
        }
        return;
    }
    
    double findMedian() {
		int n = h1.size() + h2.size();
        if(n % 2 == 1){
            return h1.top();
        }
        return 1.0 * (h1.top() + h2.top()) / 2;
    }
};
```

- 264.丑数 II

![](.\images\264.png)

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        Heap<long long> h{greater<long long>()};
        long long ans = 0;
        h.push(1);
		while(n--){
            ans = h.top();
            h.pop();
            if(ans % 5 == 0){
                h.push(ans * 5);
            }else if(ans % 3 == 0){
                h.push(ans * 5);
                h.push(ans * 3);
            }else{
                h.push(ans * 5);
                h.push(ans * 3);
                h.push(ans * 2);
            }
        }
        return ans;
    }
};
```

- 313.超级丑数

```c++
// 超出时间限制，老师能通过
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
		vector<int> p(primes.size());
        vector<int> data;
        data.push_back(1);
        int ans = 1;
        while(data.size() != n){
            ans = primes[0] * data[p[0]];
            for(int i = 1; i < primes.size(); i++){
                ans = min(ans, primes[i] * data[p[i]]);
            }
            for(int i = 0; i < primes.size(); i++){
                if(primes[i] * data[p[i]] == ans) p[i]++;
            }
            data.push_back(ans);
        }
        return ans;
    }
};
```

- 1753.移除石子的最大得分

![](.\images\1753.png)

```c++
class Solution {
public:
    int maximumScore(int a, int b, int c) {
		if(a > b)swap(a, b);
		if(a > c)swap(a, c);
		if(b > c)swap(b, c);
        int ans = 0;
        // step1
        int cnt1 = min(a, c - b);
        a -= cnt1;
        c -= cnt1;
        ans += cnt1;
        // step2
        if(a != 0){
        	if(a % 2 == 1) a -= 1;
            b -= a / 2;
            c -= a / 2;
            ans += a;
        }
        // step3
        ans += b;
        return ans;
    }
};
```

- 1801.积压订单中的订单总数

```c++
class Solution {
public:
    struct CMP1{
        bool operator()(vector<int> a, vector<int> b){
            return a[0] < b[0];
        }
    };
    struct CMP2{
        bool operator()(vector<int> a, vector<int> b){
            return a[0] > b[0];
        }
    };
    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
		Heap<vector<int>>buy{CMP1()}, sell{CMP2()};
        for(auto x : orders){
            if(x[2] == 0){
                while(x[1] != 0 && sell.size() && sell[0][0] <= x[0]){
                    int cnt = min(x[1], sell[0][1]);
                    x[1] -= cnt;
                    sell[0][1] -= cnt;
                    if(sell[0][1] == 0) sell.pop();
                }
                if(x[1] != 0) buy.push(x);
            }else{
                while(x[1] != 0 && buy.size() && buy[0][0] >= x[0]){
                    int cnt = min(x[1], buy[0][1]);
                    x[1] -= cnt;
                    buy[0][1] -= cnt;
                    if(buy[0][1] == 0) buy.pop();
                }
                if(x[1] != 0) sell.push(x);
            }
        }
        int sum = 0;
        int mod = 1000000007;
        for(auto x : buy){
            sum = (sum + x[1]) % mod;
        }
        for(auto x : sell){
            sum = (sum + x[1]) % mod;
        }
        return sum;
    }
};
```

# 六.并查集及经典问题

## 1.并查集的基础知识

(1)并查集解决连通性问题

需要维护连通关系，或者查询连通关系的问题场景，适合用并查集。

连通性性质：传递性

百变大咖：并查集

并查集是一类抽象化程度很高的数据结构

(2)Quick-Find算法

![](.\images\Quick-Find.jpg)

![](.\images\Quick-Find总结.png)

```c++
// 实现Quick-Find：查找起来快
class UnionSet {
public:
    int *color, n;
    UnionSet(int n) : n(n) {
        color = new int[n + 1];
        for(int i = 0; i <= n; i++){
            color[i] = i;
        }
    }
    int find(int x){
        return color[x];
    }
    void merge(int a, int b){
        if(color[a] == color[b]) return;
        int cb = color[b];
        for(int i = 0; i <= n; i++){
            if(color[i] == cb) color[i] = color[a];
        }
    }
};
```

(3)Quick-Union

```c++
// 实现
class UnionSet {
public:
    int *boss, n;
    UnionSet(int n) : n(n) {
        boss = new int[n + 1];
        for(int i = 0; i <= n; i++){
            boss[i] = i;
        }
    }
    int find(int x){
        if(boss[x] == x) return x;
        return find(boss[x]);
    }
    void merge(int a, int b){
        int fa = find(a), fb = find(b);
        if(fa == fb) return;
        boss[fa] = fb;
        return;
    }
};
```

按质优化：根据指标，平均查找次数，推导得出谁的节点少，谁当儿子

sa,sb节点数量、la,lb总查找次数

![](.\images\Quick-Union.png)

(4)Weighted_Quick-Union

```c++
// 优化后实现
class UnionSet {
public:
    int *fa, *size, n;
    UnionSet(int n) : n(n) {
        fa = new int[n + 1];
        size = new int[n + 1];
        for(int i = 0; i <= n; i++){
            fa[i] = i;
            size[i] = 1;
        }
    }
    int find(int x){
        if(fa[x] == x) return x;
        return find(fa[x]);
    }
    void merge(int a, int b){
        int ra = find(a), rb = find(b);
        if(ra == rb) return;
        if(size[ra] < size[rb]){
            fa[ra] = rb;
            size[rb] += size[ra];
        }else{
            fa[rb] = ra;
            size[ra] += size[rb];
        }
        return;
    }
};
```

(4)Weighted-Quick-Union-pc(路径压缩优化)

```c++
class UnionSet {
public:
    int *fa, *size, n;
    UnionSet(int n) : n(n) {
        fa = new int[n + 1];
        size = new int[n + 1];
        for(int i = 0; i <= n; i++){
            fa[i] = i;
            size[i] = 1;
        }
    }
    int find(int x){
        if(fa[x] == x) return x;
        int root = find(fa[x]);
        fa[x] = root;
        return root;
    }
    void merge(int a, int b){
        int ra = find(a), rb = find(b);
        if(ra == rb) return;
        if(size[ra] < size[rb]){
            fa[ra] = rb;
            size[rb] += size[ra];
        }else{
            fa[rb] = ra;
            size[ra] += size[rb];
        }
        return;
    }
};
```

(5)Quick-Union-pc(只有路径压缩优化)

```c++
class UnionSet {
public:
    int *fa, n;
    UnionSet(int n) : n(n) {
        fa = new int[n + 1];
        for(int i = 0; i <= n; i++){
            fa[i] = i;
        }
    }
    int find(int x){
        if(fa[x] == x) return x;
        int root = find(fa[x]);
        fa[x] = root;
        return root;
    }
    void merge(int a, int b){
        int ra = find(a), rb = find(b);
        if(ra == rb) return;
        fa[ra] = rb;
        return;
    }
};
```

(6)解题时用的标准化的并查集基础类

```c++
class UnionSet {
public:
    int *fa, n;
    UnionSet(int n) : n(n) {
        fa = new int[n + 1];
        for(int i = 0; i <= n; i++){
            fa[i] = i;
        }
    }
    int get(int x){
        return fa[x] = (fa[x] == x ? x : get(fa[x]));
    }
    void merge(int a, int b){
        fa[get(a)] = get(b);
    }
};
```

## 2.经典面试题-并查集基础题目

- 547.省份数量

```c++
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
		int n = isConnected.size();
        UnionSet u(n);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                if(isConnected[i][j]) u.merge(i, j);
            }
        }
        int ans = 0;
        for(int i = 0; i < n; i++){
            if(u.get(i) == i) ans +=1;
        }
        return ans;
    }
};
```

- 200.岛屿数量

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
		int n = grid.size(), m = grid[0].size();
        UnionSet u(n * m);
        #define ind(i,  j) ((i) * m + (j))
        for (int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == '0') continue;
                if(i > 0 && grid[i - 1][j] == '1') u.merge(ind(i, j), ind(i - 1,j));
                if(j > 0 && grid[i][j - 1] == '1') u.merge(ind(i, j), ind(i,j - 1));
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == '1' && u.get(ind(i, j)) == ind(i, j)) ans += 1;
            }
        }
        #undef ind
        return ans;
    }
};
```

- 990.等式方程的可满足性

```c++
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
		UnionSet u(26);
        for(auto s : equations){
            if(s[1] == '!') continue;
            int a = s[0] - 'a';
            int b = s[3] - 'a';
            u.merge(a, b);
        }
        for(auto s : equations){
            if(s[1] == '=') continue;
            int a = s[0] - 'a';
            int b = s[3] - 'a';
            if(u.get(a) == u.get(b)) return false;
        }
        return true;
    }
};
```

- 684.冗余连接

```c++
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
		UnionSet u(edges.size());
        for(auto e : edges){
            int a = e[0];
            int b = e[1];
            if(u.get(a) == u.get(b)) return e;
            u.merge(a, b);
        }
        return vector<int>();
    }
};
```

- 1319.连通网络的操作次数

```c++
class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
		if(connections.size() < n - 1) return -1;
        UnionSet u(n);
        for(auto e : connections){
            int a = e[0];
            int b = e[1];
            u.merge(a, b);
        }
        int cnt = 0;
        for(int i = 0; i < n; i++){
            if(u.get(i) == i) cnt += 1;
        }
        return cnt - 1;
    }
};
```

- 128.最长连续序列

```c++
class Solution {
public:
    class UnionSet {
    public:
        int *fa, *cnt, n;
        UnionSet(int n) : n(n) {
            fa = new int[n + 1];
            cnt = new int[n + 1];
            for(int i = 0; i <= n; i++){
                fa[i] = i;
                cnt[i] = 1;
            }
        }
        int get(int x){
            return fa[x] = (fa[x] == x ? x : get(fa[x]));
        }
        void merge(int a, int b){
            if(get(a) == get(b)) return;
            cnt[get(b)] += cnt[get(a)];
            fa[get(a)] = get(b);
            return;
        }
    };
    int longestConsecutive(vector<int>& nums) {
		unordered_map<int, int> ind;
        // 连接时连接数字的下标，因为数字有可能很大
        UnionSet u(nums.size());
        for(int i = 0; i < nums.size(); i++){
            int x = nums[i];
            if(ind.find(x) != ind.end()) continue;
            if(ind.find(x - 1) != ind.end()){
                u.merge(i, ind[x - 1]);
            }
            if(ind.find(x + 1) != ind.end()){
                u.merge(i, ind[x + 1]);
            }
            ind[x] = i;
        }
        int ans = 0;
        for(int i = 0; i < nums.size(); i++){
            if(u.get(i) == i && u.cnt[i] > ans) ans = u.cnt[i];
        }
        return ans;
    }
};
```

- 947.移除最多的同行或同列石头

```c++
class Solution {
public:
    int removeStones(vector<vector<int>>& stones) {
        UnionSet u(stones.size());
		unordered_map<int, int> ind_x, ind_y;
        for(int i = 0; i < stones.size(); i++){
            int x = stones[i][0];
            int y = stones[i][1];
            if(ind_x.find(x) != ind_x.end()){
                u.merge(i, ind_x[x]);
            }
            if(ind_y.find(y) != ind_y.end()){
                u.merge(i, ind_y[y]);
            }
            ind_x[x] = i;
            ind_y[y] = i;
        }
        int cnt = 0;
        for(int i = 0; i < stones.size(); i++){
            if(u.get(i) == i) cnt += 1;
        }
        return stones.size() - cnt;
    }
};
```

- 1202.交换字符串中的元素

```c++
class Solution {
public:
    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
		UnionSet u(s.size());
        priority_queue<char, vector<char>, greater<char>> h[s.size()];
        for(auto p : pairs){
            int i = p[0];
            int j = p[1];
            u.merge(i, j);
        }
        for(int i = 0; i < s.size(); i++){
            h[u.get(i)].push(s[i]);
        }
        string ret = "";
        for(int i = 0; i < s.size(); i++){
            ret += h[u.get(i)].top();
            h[u.get(i)].pop();
        }
        return ret;
    }
};
```

# 七.快速排序（Quick-Sort）及优化

## 1.快速排序的基础知识

普通的快速排序，取左边第一位数值为基准值

这种在熵很低的情况下，效率并不高

```c++
void quick_sort_v1(int *arr, int l,int r){
    if(l >= r) return;
    int x = l, y = r,base = arr[l];
    while(x < y){
        while(x < y && arr[y] >= base) y--;
        if(x < y) arr[x++] = arr[y];
        while(x < y && arr[x] < base) x++;
        if(x < y) arr[y--] = arr[x];
    }
    arr[x] = base;
    quick_sort_v1(arr, l, x - 1);
    quick_sort_v1(arr, x + 1, r);
    return;
}
```

从C++ STL学习快速排序

1.单边递归法

2.无监督partition方法（取消边界判定）

3.三点取中法

4.小数据规模，停止快排过程

5.使用插入排序进行首尾

```c++
// 左递归法：右边用递归，左边用循环
void quick_sort_v2(int *arr, int l,int r){
    while(l < r){
        int x = l, y = r,base = arr[l];
        while(x < y){
            while(x < y && arr[y] >= base) y--;
            if(x < y) arr[x++] = arr[y];
            while(x < y && arr[x] < base) x++;
            if(x < y) arr[y--] = arr[x];
        }
        arr[x] = base;
        quick_sort_v2(arr, x + 1, r);
        r = x - 1;
    }
    return;
}
```

```c++
const int threshold = 16;
inline int getmid(int a, int b, int c){
    if(a > b) swap(a, b);
    if(a > c) swap(a, c);
    if(b > c) swap(b, c);
    return b;
}

void __quick_sort_v3(int *arr, int l,int r){
    while(r - l > threshold){
        int x = l, y = r,base = getmid(arr[l], arr[(l + r) / 2], arr[r]);
        do{
            while(arr[x] < base) x++;
            while(arr[y] > base) y--;
            if(x <= y){
            	swap(arr[x], arr[y]);
                x++, y--;
            }
        }while(x <= y);
        __quick_sort_v3(arr, x, r);
        r = y;
    }
    return;
}

void final_insert_sort(int *arr, int l, int r){
    int ind = l;
    for(int i = l + 1; i <= r; i++){
        if(arr[i] < arr[ind]) ind = i;
    }
    while(ind > l){
        swap(arr[ind], arr[ind - 1]);
        ind--;
    }
    for(int i = l + 2; i <= r; i++){
        int j = i;
        while(arr[j] < arr[j - 1]){
            swap(arr[j], arr[j - 1]);
            j--;
        }
    }
    return;
}

void quick_sort_v3(int *arr, int l,int r){
    __quick_sort_v3(arr, l, r);
    final_insert_sort(arr, l, r);
}
```

## 2.快速排序扩展算法-快速排序、经典面试题-快速排序基础

用来快速查找排名第k位的元素

- 912.排序数组

```c++
// 普通快排，会超出时间限制
class Solution {
public:
    void quick_sort_v1(vector<int> &arr, int l,int r){
        if(l >= r) return;
        int x = l, y = r,base = arr[l];
        while(x < y){
            while(x < y && arr[y] >= base) y--;
            if(x < y) arr[x++] = arr[y];
            while(x < y && arr[x] < base) x++;
            if(x < y) arr[y--] = arr[x];
        }
        arr[x] = base;
        quick_sort_v1(arr, l, x - 1);
        quick_sort_v1(arr, x + 1, r);
        return;
    }
    vector<int> sortArray(vector<int>& nums) {
        quick_sort_v1(nums,0,nums.size() - 1);
        return nums;
    }
};
```

```c++
class Solution {
public:
    const int threshold = 16;
    inline int getmid(int a, int b, int c){
        if(a > b) swap(a, b);
        if(a > c) swap(a, c);
        if(b > c) swap(b, c);
        return b;
    }

    void __quick_sort_v3(vector<int> &arr, int l,int r){
        while(r - l > threshold){
            int x = l, y = r,base = getmid(arr[l], arr[(l + r) / 2], arr[r]);
            do{
                while(arr[x] < base) x++;
                while(arr[y] > base) y--;
                if(x <= y){
                    swap(arr[x], arr[y]);
                    x++, y--;
                }
            }while(x <= y);
            __quick_sort_v3(arr, x, r);
            r = y;
        }
        return;
    }

    void final_insert_sort(vector<int> &arr, int l, int r){
        int ind = l;
        for(int i = l + 1; i <= r; i++){
            if(arr[i] < arr[ind]) ind = i;
        }
        while(ind > l){
            swap(arr[ind], arr[ind - 1]);
            ind--;
        }
        for(int i = l + 2; i <= r; i++){
            int j = i;
            while(arr[j] < arr[j - 1]){
                swap(arr[j], arr[j - 1]);
                j--;
            }
        }
        return;
    }

    void quick_sort_v3(vector<int> &arr, int l,int r){
        __quick_sort_v3(arr, l, r);
        final_insert_sort(arr, l, r);
    }
    vector<int> sortArray(vector<int>& nums) {
        quick_sort_v3(nums,0,nums.size() - 1);
        return nums;
    }
};
```

- 剑指Offer21.调整数组顺序使奇数位于偶数前面

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        if(num.size() == 0) return nums;
        int x = 0, y = nums.size() - 1;
        do{
            while(x < y && nums[x] % 2) x++;
            while(x < y && nums[y] % 2 == 0) y--;
            if(x < y){
                swap(nums[x], nums[y]);
                x++, y--;
            }
        }while(x < y);
        return nums;
    }
};
```

- 148.排序链表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
		if(head == NULL) return head;
        int l = head->val, r = head->val;
        // int类型负数/2会变为正数，初始化为double
        double mid;
        // h1、h2需要初始化为NULL，不能存值，不然遍历时会把这两个假节点遍历进去（实验时下一行代码会报错）
        ListNode *p = head, *q, *h1 = NULL, *h2 = NULL;
        while(p) l = min(p->val, l), r = max(p->val, r), p = p->next;
        if(l == r) return head;
        mid = (l + r) / 2.0;
        p = head;
        while(p){
            q = p->next;
            if(p->val <= mid){
                p->next = h1;
                h1 = p;
            }else{
                p->next = h2;
                h2 = p;
            }
            p = q;
        }
        h1 = sortList(h1);
        h2 = sortList(h2);
        p = h1;
        while(p->next) p = p->next;
        p->next = h2;
        return h1;
    }
};
```

- 75.颜色分类

```c++
// 三个数据partition x占着0，y占着2，x是0的最后一位，所以下一位不是i(0)就一定是1，x下一位是i(0)时会一起向后走，是1时互换后i也可以直接向后走一位
class Solution {
public:
    void three_partition(vector<int>& nums, int l, int r, int mid){
        if(l >= r) return;
        int x = -1, y = r + 1, i = l;
        while(i < y){
            if(nums[i] == mid){
                i++;
            }else if(nums[i] < mid){
                x++;
                swap(nums[x], nums[i]);
                i++;
            }else if(nums[i] > mid){
                y--;
                swap(nums[y], nums[i]);
            }
        }
    }
    void sortColors(vector<int>& nums) {
        three_partition(nums, 0, nums.size() - 1, 1);
    }
};
```

- 面试题17.14.最小K个数

```c++
class Solution {
public:
    int getmid(int a, int b, int c){
        if(a > b) swap(a, b);
        if(a > c) swap(a, c);
        if(b > c) swap(b, c);
        return b;
    }
    void quick_select(vector<int>& arr, int l, int r,int k){
        if(l >= r) return;
        int x = l, y = r, mid = getmid(arr[l], arr[(l + r) / 2], arr[r]);
        do{
            while(arr[x] < mid) x++;
            while(arr[y] > mid) y--;
            if(x <= y){
                swap(arr[x], arr[y]);
                x++, y--;
            }
        }while(x <= y);
        if(y - l == k - 1) return;
        if(y - l >= k) {
            quick_select(arr, l, y, k);
        }else{
            quick_select(arr, x, r, k - x + l);
        }
        return;
    }
    vector<int> smallestK(vector<int>& arr, int k) {
		vector<int> ans;
        if(k == 0) return ans;
        quick_select(arr, 0, arr.size() - 1, k);
        while(k) ans.push_back(arr[--k]);
        return ans;
    }
};
```

- 95.不同的二叉搜索树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> dfs(int l, int r){
        vector<TreeNode*> ans;
        if(l > r){
            ans.push_back(nullptr);
            return ans;
        }
        for(int i = l; i <= r; i++){
            vector<TreeNode*> left_tree = dfs(l, i - 1);
            vector<TreeNode*> fight_tree = dfs(i + 1, r);
            for(TreeNode* left : left_tree){
                for(TreeNode* right : fight_tree){
                	TreeNode* t = new TreeNode(i, left, right);
                    ans.push_back(t);
            	}
            }
        }
        return ans;
    }
    vector<TreeNode*> generateTrees(int n) {
		if(n == 0) return vector<TreeNode*> ();
        return dfs(1, n);
    }
};
```

- 394.字符串解码

```c++
class Solution {
public:
    string decodeString(string s) {
		string ret;
        int i = 0;
        while(s[i]){
            if(s[i] < '0' || s[i] > '9'){
                ret += s[i];
                i++;
            }else{
                int num = 0;
                while(s[i] >= '0' && s[i] <= '9'){
                    num = num * 10 + (s[i++] - '0');
                }
                i++;
                int l = i, r = i, cnt = 1;
                while(cnt){
                    r += 1;
                    if(s[r] == '[') cnt++;
                    else if(s[r] == ']') cnt--;
                }
                string tmp = decodeString(s.substr(l, r - l));
                while(num--) ret += tmp;
                i = r + 1;
            }
        }
        return ret;
    }
};
```

- 11.盛最多水的容器

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
		int ans = 0, i = 0, j = height.size() - 1;
        while(i < j){
            ans = max(ans, (j - i) * min(height[i], height[j]));
            if(height[i] < height[j]) i++;
            else j--;
        }
        return ans;
    }
};
```

- 470.用 Rand7() 实现 Rand10()

```
// 没讲
```

- 239.滑动窗口最大值

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		vector<int> ans;
        if(k == 0) return ans;
        deque<int> q;
        int idx = 0;
        while(idx < nums.size()){
            if(!q.empty() && q.front() + k <= idx){
                q.pop_front();
            }
            while(!q.empty() && nums[q.back()] < nums[idx]){
                q.pop_back();
            }
            q.push_back(idx);
            idx++;
            if(idx >= k) ans.push_back(nums[q.front()]);
        }
        return ans;
    }
};
```

# 八.归并排序（Merge-Sort）：从二路到多路

## 1.归并排序的基础知识

快速排序是内部排序，归并排序是外部排序

```c++
void merge_sort(int *arr, int l, int r){
    if(l >= r) return;
    int mid = (l + r) >> 1;
    merge_sort(arr, l, mid);
    merge_sort(arr, mid + 1, mid);
    int *temp = (int *)malloc(sizeof(int) * (r - l + 1));
    int k = 0, p1 = l, p2 = mid + 1;
    while(p1 <= mid || p2 <= r){
        if((p2 > r) || (p1 <= mid && arr[p1] <= arr[p2])){
            temp[k++] = arr[p1++];
        }else{
            temp[k++] = arr[p2++];
        }
    }
    for(int i = l; i <= r; i++) arr[i] = temp[i - l];
    free(temp);
    return;
}
```

(1).归并排序在大数据场景下的应用

问题：电脑内存大小2GB，如何对一个40GB的文件进行排序？

使用多路归并排序（20路），需要在20路中选出最小值，使用小顶堆

代码展示了合并两个文件中的数据，书籍推荐：**深入理解计算机系统**

(2)归并排序的算法思想

左边处理一下，得到左边的信息

右边处理一下，得到右边的信息

最后再处理，横跨左右两边的信息

## 2.经典面试题-归并排序基础

- 剑指 Offer 51.数组中的


```c++
class Solution {
public:
    vector<int> temp;
    int countResult(vector<int>& nums, int l, int r){
        if(l >= r) return 0;
        int ans = 0, mid = (l + r) >> 1;
        ans += countResult(nums, l, mid);
        ans += countResult(nums, mid + 1, r);
        int k = l, p1 = l, p2 = mid + 1;
        while(p1 <= mid || p2 <= r){
            if((p2 > r) || (p1 <= mid && nums[p1] <= nums[p2])){
                temp[k++] = nums[p1++];
            }else{
                temp[k++] = nums[p2++];
                ans += (mid - p1 + 1);
            }
        }
        for(int i = l; i <= r; i++) nums[i] = temp[i];
        return ans;
    }
    int reversePairs(vector<int>& nums) {
        // 使得temp数组和原数组一样长
		while(temp.size() < nums.size()) temp.push_back(0);
        return countResult(nums, 0, nums.size() - 1);
    }
};
```

- 合并K个升序链表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    struct CMP{
        bool operator()(ListNode *p, ListNode *q){
            return p->val > q->val;
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
		priority_queue<ListNode *, vector<ListNode *>, CMP> q;
        for(auto x : lists){
            if(x == nullptr) continue;
            q.push(x);
        }
        ListNode ret, *p = &ret;
        while(!q.empty()){
            ListNode *cur = q.top();
            q.pop();
            p->next = cur;
            p = cur;
            if(cur->next) q.push(cur->next);
        }
        return ret.next;
    }
};
```

- 148.排序链表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode *mergeSort(ListNode *head, int n){
        if(head == nullptr || head->next == nullptr) return head;
        int l = n / 2, r = n - l;
        ListNode *lp = head, *rp = lp, *p;
        for(int i = 1; i < l; i++, rp = rp->next);
        p = rp, rp = rp->next;
        p->next = nullptr;
        lp = mergeSort(lp, l);
        rp = mergeSort(rp, r);
        ListNode ret;
        p = &ret;
        while(lp || rp){
            if((rp == nullptr) || (lp && lp->val <= rp->val)){
                p->next = lp;
                lp = lp->next;
                p = p->next;
            }else{
                p->next = rp;
                rp = rp->next;
                p = p->next;
            }
        }
        return ret.next;
        
    }
    ListNode* sortList(ListNode* head) {
		int n = 0;
        ListNode *p = head;
        while(p) p = p->next, n += 1;
        return mergeSort(head, n);
    }
};
```





























































































