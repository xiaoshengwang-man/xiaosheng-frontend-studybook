# 一.链表

## 1.链表基本知识

![image-20211027220921831](.\images\链表结构.png)



![image-20211027220951250](.\images\链表介绍.png)

## 2.单向链表第一种实现

```c++
struct Node {
    Node(int data) : data(data),next(NULL){};
    int data;
    Node *next;
}

int main(){
    Node *head = NULL;
    head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    Node *p = head;
    while(p != NULL){
        printf("%d->",p->data);
        p = p->next
    }
    printf("\n");
    return 0;
}
```

## 3.单向链表第二中实现形式

```c++
int data[10];
int next[10];
void add(int ind,int p,int val){
    next[p] = next[ind];// 支持中间插入
    next[ind] = p;
    data[p] = val;
    return;
}
int main(){
    int head = 3;
    data[3] = 0;
    add(3,5,1);
    add(5,2,2);
    add(2,7,3);
    add(7,9,100);
    add(5,6,2);// 支持中间插入
    int p = head;
    while(p != 0){
        printf("%d->",data[p]);
        p = next[p];
    }
    printf("\n");
    return 0;
}
```

## 4.彩蛋课程

作业答案补充到url[彩蛋](https://xue.kaikeba.com/static/KKB000000.mp4)

## 5.场景

场景一：操作系统内的动态内存分配

![image-20211031231317110](.\images\链表的典型应用1.png)

场景二：LRU缓存淘汰算法

![image-20211031231935667](.\images\链表的典型应用2.png)

## 6.面试题-链表的访问

- 141.环形链表：给定一个链表，判断链表中是否有环。

  - 思路一：哈希表；总结起来就是，我们只需要遍历这个链表，在遍历的过程中记录我们遍历过的节点，如果遇到next节点为null的节点，说明没有环。如果遇到我们之前遍历过的节点，说明有环。

  - 思路二：快慢指针；如果链表有环，那么快慢指针一定会相遇，指向同一个节点，当指向同一个节点时，遍历结束

    ```c++
    bool hasCycle(ListNode *head){
        if(head == nullptr) return false;
        ListNode *p = head,*q = head->next;
        while(p != q && q && q->next){
            p = p->next;
            q = q->next->next;
        }
        return q && q->next;
    }
    ```


- 142环形链表Ⅱ：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

  ![](.\images\链表起点.png)

```c++
ListNode *detectCycle(ListNode *head){
	if(head == nullptr) return nullptr;
    ListNode *p = head,*q = head->next;
    while(p != q && q && q->next){
        p = p->next;
        q = q->next->next;
    }
    if(q == nullptr || q->next == nullptr) return nullptr;
    // 思考：可以把注释包裹的代码删除掉，我觉得应该是再判断if(head.next == nullptr) return 		nullptr;一个节点不可能成环，然后可直接初始化p、q为下面的值
    // 之所以初始化先走一步而不是都从head开始，因为判断条件要p和q不相等，都从head开始可以改为		do{}while{}
    p = head->next;q = head->next->next;
    while(p != q){
        p = p->next;
        q = q->next->next;
    }
    // 到这
    p = head;
    while(p != q){
        p = p->next;
        q = q->next;
    }
    return q;
}
```

```c++
// 上面思考的实现,想的没有错
ListNode *detectCycle(ListNode *head){
	if(head == nullptr) return nullptr;
    ListNode *p = head,*q = head;
    if(q->next == nullptr) return nullptr;
    do {
        p = p->next;
        q = q->next->next;
    }while(p != q && q && q->next);
    if(q == nullptr || q->next == nullptr) return nullptr;
    p = head;
    while(p != q){
        p = p->next;
        q = q->next;
    }
    return q;
}
```

- 202.快乐数

转换成环状链表，链表思维：唯一指向性

形参是整数类型，按各位平方相加，最大应该是1999999999=>730，所以链表最多7

30个节点

```c++
int getNext(int x){
    int z = 0;
    while(x){
        z += (x%10) * (x%10);
        x /= 10;
    }
    return z;
}
bool isHappy(int n){
    int p = n,q = n;
    do{
        p = getNext(p);
        q = getNext(getNext(q));
    }while(p != q && q!=1);
    return q == 1;
}
```

## 7.链表的反转

- 206.反转链表

![](.\images\反转链表init.png)

(1)定义指针——pre,pre指向空

定义指针——cur,cur指向我们的头节点

定义指针——next,next指向cur所指向节点的下一个节点，这样我们的指针就初始化完毕了

首先，我们将cur指针所指向的节点指向pre指针所指向的节点

然后移动指针pre到指针cur所在的位置，移动cur到next所在的位置，此时，我们已经反转了第一个节点

将我们的next指针指向cur指针所指向节点的下一个节点

然后重复上述操作

当cur指针指向null的时候，我们就完成了整个链表的反转

```c++
ListNode *reverseList(ListNode *head){
	if(head == nullptr) return head;
    ListNode *pre = nullptr,*cur = head,*p = head->next;
    while(cur){
        cur->next = pre;
        pre = cur;
        // 与逻辑，当cur指向空地址时不执行后面的赋值
        (cur = p) && (p = p->next);
    }
    return pre;
}
```

(2)基于递归的输出反转链表

递归的回复过程，相当于逆序的遍历链表，不影响原链表排序

```c++
void reverse(Node *p){
    if(p == NULL)return;
    reverse(p->next);
    printf("%d->",p->data);
    return;
}
```

基于这个思想，编写反转原链表

```c++
ListNode *reverseList(ListNode *head){
	if(head == nullptr || head->next == nullptr) return head;
    ListNode *tail = head-> next ,*p = reverseList(head->next);
    head->next = tail->next;
    tail->next = head;
    return p;
}
```

多传递一个数值，可控制反转头几个节点

```c++
ListNode *reverseN(ListNode *head,int n){
	if(n == 1) return head;
    ListNode *tail = head-> next ,*p = reverseN(head->next,n-1);
    head->next = tail->next;
    tail->next = head;
    return p;
}
```

- 92反转链表Ⅱ

反转从位置m到n的链表。请使用一趟扫描完成反转。

```c++
// 虚拟头节点：不需要判断是否是头一个节点
// 需要用到上面反转前n个节点的方法
ListNode* reverseBetween(ListNode* head,int m,int n){
    ListNode ret(0, head),*p = &ret;
    int cnt = n - m + 1;
    while(--m) p = p->next;
    p->next = reverseN(p->next,cnt);
    return ret.next;
}
```

- 25.K个一组反转链表

```c++
ListNode *__reverseN(ListNode *head,int n){
	if(n == 1) return head;
    ListNode *tail = head-> next ,*p = __reverseN(head->next,n-1);
    head->next = tail->next;
    tail->next = head;
    return p;
}
ListNode *reverseN(ListNode *head,int n){
    ListNode *p = head;
    int cnt = n;
    while(--n && p) p = p->next;
    if(p == nullptr)return head;
    return __reverseN(head,cnt);   
}
ListNode* reverseKGroup(ListNode* head, int k){
    ListNode ret(0,head),*p = &ret,*q = ret.next;
    while((p->next = reverseN(q,k)) != q){
        p = q;
        q = p->next;
    }  
    return ret.next;
}


```

- 61 旋转链表

把链表首尾相连，移动即可

```c++
ListNode *rotateRight(ListNode *head,int k){
    if(head == nullptr) return nullptr;
    int n = 1;
    ListNode *p = head;
    while(p->next) p = p->next,n += 1;
    p->next = head;
    k %= n;
    k = n - k;
    // k--是走到了head的前一位，即链表尾部
    while(k--) p = p->next;
    head = p->next;
    p->next = nullptr;
	return head;
}
```

## 8.链表的节点删除

- 19删除链表的倒数第N个结点

![](.\images\删除倒数N节点.png)

```c++
ListNode* removeNthFromEnd(ListNode* head,int n){
    ListNode ret(0,head), *p = &ret,*q = head;
    while(n--)q = q->next;
    while(q)p = p->next,q = q->next;
    p->next = p->next->next;
    return ret.next;
}
```

- 83.删除排序列表中的重复节点

```c++
ListNode* deleteDuplicates(ListNode* head){
	if(head == nullptr) return nullptr;
    ListNode *p = head;
    while(p->next){
        if(p->val == p->next->val){
            p->next = p->next->next;
        }else{
            p = p->next;
        }
    }
    return head;
}
```

- 82删除排序链表中的重复元素Ⅱ

```c++
ListNode* deleteDuplicates(ListNode* head){
    ListNode ret(0,head), *p = &ret, *q;
    while(p->next){
        if(p->next->next && p->next->val == p->next->next->val){
            q = p->next->next;
            while(q && q->val == p->next->val)q = q->next;
            p->next = q;
        }else{
            p = p->next;
        }
    }
    return ret.next;
}
```

什么时候用虚头：链表头地址有可能改变

# 二线程池与任务队列（Task-Queue）

## 1.队列基础知识

(1)标准队列：两个指针，一个头指针，一个尾指针，**尾指针指向最后一个节点的下一位**，头部出队，尾部入队，先入先出

(2)假溢出：其实还有位置可以放入其他元素，只是因为尾指针走到了最后一位，普通队列会误以为队列满了，为了解决假溢出，提出循环队列

(3)循环队列：走到尾部，再从头开始

![](.\images\循环队列.jpg)

(4)循环队列并不是特殊的队列，只是为了有效利用队列的空间，而提出的一种队列对假溢出的一种处理方式

## 2.几种经典的队列实现方法

(1)标准队列

```c++
class Quene{
    public:
    Quene(int n = 10): arr(n), head(0), tail(0){}
    void push(int x){
        if(full())return;
        arr[tail] = x;
        tail += 1;
        return;
    }// 入队
    void pop(){
        if(empty())return;
        head += 1;
        return;
    }// 出队
    // 为什么尾指针指向最后一个节点的下一位，源于各种语言描述一个区间的时候，采用左闭右开的区间描述方式，头尾指针标记的就是队列的区间，左闭右开还有个好处，tail-head等于当前元素的数量
    bool empty(){
        return head == tail;
    }// 判空
    bool full(){
        return tail == arr.size();
    }// 判满
    int front(){
        return arr[head];
    }// 查看队首元素
    int size(){
        return tail - head;
    }
    void output(){
        cout << "Queue : ";
        for(int i = head;i < tail,i++){
            cout << arr[i] << " ";
        }
        cout << endl;
        return;
    }
    private:
    int head,tail;
    // 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。
    vector<int> arr;
}
```

（2）循环队列

```c++
class Quene{
    public:
    Quene(int n = 10): arr(n), head(0), tail(0), cnt(0){}
    void push(int x){
        if(full())return;
        arr[tail] = x;
        tail += 1;
        cnt += 1;
        if(tail == arr.size())tail = 0;
        return;
    }// 入队
    void pop(){
        if(empty())return;
        head += 1;
        cut -= 1
        if(head == arr.size())head = 0;
        return;
    }// 出队
    bool empty(){
        return cnt == 0;
    }// 判空
    bool full(){
        return cnt == arr.size();
    }// 判满
    int front(){
        return arr[head];
    }// 查看队首元素
    int size(){
        return cnt;
    }
    void output(){
        cout << "Queue : ";
        for(int i = 0,j = head;i < cnt,i++){
            cout << arr[i] << " ";
            j += 1;
            if(j == arr.size()) j = 0;
        }
        cout << endl;
        return;
    }
    private:
    int head,tail;
    int cnt;// 当前队列的元素数量
    vector<int> arr;
}
```

## 3.队列的典型应用场景

(1)场景一：CPU的超线程技术

![](.\images\队列场景一.png)

(2)线程池的任务队列

![](.\images\队列场景二.png)

## 4.队列刷题

- 86.分隔链表

```c++
ListNode* partition(ListNode* head,int x){
	ListNode r1,r2,*p1 = &r1,*p2 = &r2,*p = head,*q;
    while(p){
        q = p->next;
        if(p->val < x){
            p->next = p1->next;
            p1->next = p;
            p1 = p;
        }else{
            p->next = p2->next;
            p2->next = p;
            p2 = p;
        }
        p = q;
    }
    p1->next = r2.next;
    return r1.next;
        
}
```

- 138.复制带随机指针的链表

```c++
Node* copyRandomList(Node* head){
    if(head == nullptr) return nullptr;
    Node *p = head,*q,*new_head;
    // 复制
    while(p){
        q = new Node(p->val);
        q->random = p->random;
        q->next = p->next;
        p->next = q;
        p = q->next;
    }
    // 修正random指针
    p = head->next;
    while(p){
        if(p->random) p->random = p->random->next;
        (p = p->next) && (p = p->next);
    }
    // 拆分成两个链表
    new_head = head->next;
    p = head;
    while(p){
        q = p->next;
        p->next = q->next;
        if(p->next) q->next = p->next->next;
        p = p->next;
    }
    return new_head;
}
```

## 5.队列的封装与使用

- 622.设计循环队列

```c++
class MyCircularQueue{
public:
    vector<int> arr;
    int head,tail,cnt;
    MyCircularQueue(int k) : arr(k), head(0), tail(0),cnt(0) {}
    
    bool enQueue(int value){
        if(isFull()) return false;
        arr[tail] = value;
        // 循环起来
        tail = (tail + 1) % arr.size();
        cnt += 1;
        return true;
    }
    
    bool deQueue(){
        if(isEmpty()) return false;
        head = (head + 1) % arr.size();
        cnt -= 1;
        return true;
    }
    
    int Front(){
        if(isEmpty()) return -1;
        return arr[head];
    }
    
    int Rear(){
        if(isEmpty()) return -1;
        // 处理负数的情况
        return arr[(tail - 1 + arr.size()) % arr.size()];
    }
    
    bool isEmpty(){
        return cnt == 0;
    }
    
    bool isFull(){
        return cnt == arr.size();
    }
};
```

- 641 设计双向循环队列

```c++
class MyCircularDeque {
public:
    vector<int> arr;
    int head,tail,cnt;
    MyCircularDeque(int k) : arr(k), head(0), tail(0),cnt(0) {}
    
    bool insertFront(int value) {
		if(isFull()) return false;
        // 循环起来
        head = (head - 1 + arr.size()) % arr.size();
        arr[head] = value;
        cnt += 1;
        return true;
    }
    
    bool insertLast(int value) {
		if(isFull()) return false;
        arr[tail] = value;
        // 循环起来
        tail = (tail + 1) % arr.size();
        cnt += 1;
        return true;
    }
    
    bool deleteFront() {
		if(isEmpty()) return false;
        head = (head + 1) % arr.size();
        cnt -= 1;
        return true;
    }
    
    bool deleteLast() {
		if(isEmpty()) return false;
        tail = (tail - 1 + arr.size()) % arr.size();
        cnt -= 1;
        return true;
    }
    
    int getFront() {
		if(isEmpty()) return -1;
        return arr[head];
    }
    
    int getRear() {
		if(isEmpty()) return -1;
        // 处理负数的情况
        return arr[(tail - 1 + arr.size()) % arr.size()];
    }
    
    bool isEmpty(){
        return cnt == 0;
    }
    
    bool isFull(){
        return cnt == arr.size();
    }
};
```

- 1670 设计前中后队列

```c++
// 先实现一个链表结构的双端队列
class Node {
public:
    int val;
    Node *next, *pre;
    Node(int val = 0, Node *next = nullptr,Node *pre = nullptr) : val(val), next(next),pre(pre){}
    void insert_pre(Node *p){
        p->pre = pre;
        p->next = this;
        if(this->pre) this->pre->next = p;
        this->pre = p;
        return;
    }
    void insert_next(Node *p){
        p->pre = this;
        p->next = this->next;
        if(this->next) this->next->pre = p;
        this->next = p;
        return;
    }
    void delete_pre(){
       if(this->pre == nullptr) return;
        Node *p = this->pre;
        this->pre = p->pre;
        if(p->pre) p->pre->next = this;
        delete p;
        return;
    }
    void delete_next(){
       if(this->next == nullptr) return;
        Node *p = this->next;
        this->next = p->next;
        if(p->next) p->next->pre = this;
        delete p;
        return;
    }
};
class Queue{
public:	
    // 虚拟头、尾
    Node head,tail;
    int cnt;
    Queue() : cnt(0) {
        head.next = &tail;
        head.pre = nullptr;
        tail.next = nullptr;
        tail.pre = &head;
    }
    void push_back(int val){
        tail.insert_pre(new Node(val));
        cnt +=1;
        return;
    }
    void push_front(int val){
        head.insert_next(new Node(val));
        cnt +=1;
        return;
    }
    int pop_back(){
        if(isEmpty()) return -1;
        int ret = tail.pre->val;
        tail.delete_pre();
        cnt -=1;
        return ret;
    }
    int pop_front(){
        if(isEmpty()) return -1;
        int ret = head.next->val;
        head.delete_next();
        cnt -=1;
        return ret;
    }
    int front(){
        return head.next->val;
    }
    int back(){
        return tail.pre->val;
    }
    bool isEmpty(){
        return head.next == &tail;
    }
    int size(){
        return cnt;
    }
};
```



```c++
class FrontMiddleBackQueue {
public:
    Queue q1,q2;
    FrontMiddleBackQueue() {}
    
    void pushFront(int val) {
		q1.push_front(val);
        update();
        return;
    }
    
    void pushMiddle(int val) {
        // 奇数时1,3,2 插入到3前面，所以先移动
		if(q1.size() > q2.size()){
            q2.push_front(q1.back());
            q1.pop_back();
        }
        q1.push_back(val);
        return;
    }
    
    void pushBack(int val) {
		q2.push_back(val);
        update();
        return;
    }
    
    int popFront() {
		if(isEmpty()) return -1;
        int ret = q1.pop_front();
        update();
        return ret;
    }
    
    int popMiddle() {
        // 奇数偶数都是移除p1末尾元素
		if(isEmpty()) return -1;
        int ret = q1.pop_back();
        update();
        return ret;
    }
    
    int popBack() {
		if(isEmpty()) return -1;
        int ret; 
        if(q2.isEmpty()){
        	ret = q1.pop_back();
        }else{
            ret = q2.pop_back();
        }
        update();
        return ret;
    }
    bool isEmpty(){
        // 因为q1总比q2长，q1为空，q2也一定为空
        return q1.size() == 0;
    }
    void update(){
        if(q1.size() < q2.size()){
            q1.push_back(q2.front());
            q2.pop_front();
        }
        if(q1.size() == q2.size() + 2){
            q2.push_front(q1.back());
            q1.pop_back();
        }
        return;
    }
};
```

- 933最近请求次数

```c++
class RecentCounter{
public:
	queue<int> q;
    RecentCounter(){}
    
    int ping (int t){
        q.push(t);
        while(t - p.front() > 3000) p.pop();
        return q.size();
    }
}
```

## 6.经典面试题-智力发散题

- 17.09第k个数

```c++
class Solution {
public:
    int getKthMagicNumber(int k) {
		vector<int> arr;
        arr.push_back(1);
        int p3 = 0,p5 = 0,p7 = 0;
         while(arr.size() < k){
            int ans = 3 * arr[p3];
            ans = min(ans, 5 * arr[p5]);
            ans = min(ans, 7 * arr[p7]);
            if(ans == 3 * arr[p3]) p3++;
            if(ans == 5 * arr[p5]) p5++;
            if(ans == 7 * arr[p7]) p7++;
            arr.push_back(ans);
        }
        return arr[k-1];
    }
};
```

- 859.亲密字符串

```c++
class Solution {
public:
    bool has_repeate(string a){
        int cnt[26] = {0};
        for(int i = 0; a[i]; i++){
            cnt[a[i] - 'a'] += 1;
            if(cnt[a[i] - 'a'] == 2) return true;
        }
        return false;
    }
    bool buddyStrings(string a, string b) {
		if(a.size() != b.size()) return false;
        // 这里自己写的时候错了，特殊情况下重复返回true
        //if(a == b && !has_repeate(a)) return false;
        if(a == b) return has_repeate(a);
        int i = 0,j;
        while(a[i] == b[i]) ++i;
        j = i + 1;
        while(j < a.size() && a[j] == b[j]) ++j;
        if(j == a.size()) return false;
        if(a[i] != b[j] || a[j] != b[i]) return false;
        j += 1;
        while(j < a.size()){
            if(a[j] != b[j]) return false;
            j += 1;
        }
        return true;
    }
};
```

- 860柠檬水找零

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
		int cnt5 = 0, cnt10 = 0;
        for(int i = 0; i < bills.size(); i++){
            switch(bills[i]){
                case 5:cnt5 += 1;break;
                case 10: {
                    if(cnt5 == 0)return false;
                    cnt5 -=1; cnt10 +=1;
                } break;
                case 20: {
                    if(cnt10 && cnt5){
                        cnt10 -= 1;cnt5 -= 1;
                    }else if(cnt5 >= 3){
                        cnt5 -= 3;
                    }else{
                        return false;
                    }
                }break;
            }
        }
        return true;
    }
};
```

- 969.煎饼排序

```c++
class Solution {
public:
    void reverse(vector<int> &arr, int n, vector<int> &ind){
        for(int i = 0,j = n - 1; i < j; i++,j--){
            swap(arr[i], arr[j]);
            // arr已经反转，把变化的位置重新赋一下ind既可
            ind[arr[i]] = i;
            ind[arr[j]] = j;
        }
        return;
    }
    vector<int> pancakeSort(vector<int>& arr) {
		vector<int> ind(arr.size() + 1);
        vector<int> ret;
        for(int i = 0; i < arr.size(); i++) ind[arr[i]] = i;
        for(int i = arr.size(); i >= 1; i--){
            // 如果已经在正确的位置上，就进行下面的翻转操作了
            if(ind[i] == i - 1) continue;
            // 当前元素下标是0时不用翻转，因为本来就是要把元素反转到第一位，已经在第一位时，就不用翻转了
            if(ind[i] != 0){
                ret.push_back(ind[i] + 1);
                reverse(arr, ind[i] + 1, ind);
            }
            // 当前元素是1，不翻转
            if(i != 1){
                ret.push_back(i);
                reverse(arr, i, ind);
            }  
        }
        return ret;
    }
};
```

- 621任务调度

![](.\images\621任务调度.jpg)

```c++
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
		int cnt[26] = {0};
        for(int i = 0; i < tasks.size(); i++) cnt[tasks[i] - 'A'] += 1;
        sort(cnt, cnt + 26);
        int m = 0;
        // 求有几个元素是最大值
        for(int i = 25; i > 0 && cnt[i] == cnt[25]; i--, m++);
        return max((int)tasks.size(), (cnt[25] - 1) * (n + 1) + m);
    }
};
```

# 三.栈

## 1.基础知识

(1)基本操作：出栈入栈

(2)先入后出，后入先出

## 2.栈适合解决什么问题

(1)括号匹配

结论：①在任意一个位置上，左括号数量>=右括号数量

②在最后一个位置上，左括号数量==右括号数量

③程序中只需要记录左括号数量和右括号数量即可

v1

![](.\images\括号匹配v1.png)

v2

<img src=".\images\括号匹配v2.png" style="zoom:67%;" />

### 括号匹配思考

![](.\images\括号匹配思考.png)

得出：栈可以处理具有完全包含关系的问题

## 3.经典的栈实现方法

```c++
// 用vector实现的
class Stack{
public:
    Stack(){}
    void push(int x){
        data.push_back(x);
        return;
    }
    void pop(){
        if(empty()) return;
        data.pop_back(x);
        return;
    }
    bool empty(){
        return data.size() == 0;
    }
    int size(){
        return data.size();
    }
    void output(){
        cout << "======" << endl;
        for(int i = data.size() - 1; i >= 0; i--){
            cout << "  " << data[i] << endl;
        }
        cout << "======" << endl;
        return;
    }
private:
    vector<int> data;
}
```

```c++
// 用普通数组实现
class Stack{
public:
    Stack(int n = 100){
        top = -1;
        data = new int[n]
    }
    void push(int x){
        top += 1;
        data[top] = x;
        return;
    }
    void pop(){
        if(empty()) return;
        top -= 1;
        return;
    }
    bool empty(){
        return top == -1;;
    }
    int size(){
        return top + 1;
    }
    void output(){
        cout << "======" << endl;
        for(int i = top; i >= 0; i--){
            cout << "  " << data[i] << endl;
        }
        cout << "======" << endl;
        return;
    }
private:
    int *data, top;
}
```

## 4.栈的典型应用场景

1.栈应用场景一

![](.\images\栈应用场景一.jpg)

爆栈

![](.\images\爆栈.png)

2.栈应用场景二

是什么表达式取决于最后一个运算符，为了找到最后一个运算符，所以给运算符人为设定数值上的优先级，括号内的加100

![](.\images\栈应用场景二.png)

```c++
int calc(char *s, int l, int r){
    // 最小优先级的位置，最小优先级的大小，当前运算符优先级，控制出现'('、')'优先级
    int op = -1,pri = 10000 - 1, cur_pri, temp = 0;
    for(int i = l;i <= r; i++){
        cur_pri = 10000;
        switch (s[i]) {
            case '+':
            case '-': cur_pri = 1 + temp;break;
            case '*':
            case '/': cur_pri = 2 + temp;break;
            case '(': temp += 100; break;
            case ')': temp -= 100; break;
        }
        if(cur_pri <= pri){
            pri = cur_pri;
            op = i;
        }
    }
    // 说明表达式没有运算符
    if(op == -1){
        int num = 0;
        for(int i = l, i <= r; i++){
            if(s[i] < '0' || s[i] > '9') continue;
            num = num * 10 + (s[i] - '0');
        }
        return num;
    }
    int a = calc(s, l, op - 1);
    int b = calc(s, op + 1, r);
    switch (s[op]) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
    }
    return 0;
}
int main(){
    char s[100];
    while(~scanf("%[^\n]s", s)){ // 读入表达式
        getchar();
        printf("%s = %d\n", s, calc(s, 0, strlen(s) - 1));
    }
    return 0;
}
```

## 5.经典面试题-栈的基本操作

- 03.04化栈为队

```c++
s2入队〇〇〇|①②③
s1出队①②③|〇〇〇
s1出队②③|〇〇〇
s2入队②③|④⑤⑥
class MyQueue {
public:
    stack<int> s1,s2;
    /** Initialize your data structure here. */
    MyQueue() {}
    
    /** Push element x to the back of queue. */
    void push(int x) {
		s2.push(x);
        return;
    }
    
    void transfer(){
        if(!s1.empty()) return;
        while(!s2.empty()){
            s1.push(s2.top());
            s2.pop();
        }
        return;
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
		transfer();
        int ret = s1.top();
        s1.pop();
        return ret;
    }
    
    /** Get the front element. */
    int peek() {
		transfer();
        return s1.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
		return s1.empty() && s2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

- 682棒球比赛

```c++
class Solution {
public:
    stack<int> s;
    int calPoints(vector<string>& ops) {
		for(int i = 0; i < ops.size(); i++){
            if(ops[i] == "+"){
                int a = s.top();s.pop();
                int b = s.top();
                s.push(a), s.push(a + b);
            }else if(ops[i] == "D"){
                s.push(s.top() * 2);
            }else if(ops[i] == "C"){
                s.pop();
            }else{
                s.push(atoi(ops[i].c_str()));// 把字符串转化为数字
            }
        }
        int sum = 0;
        while(!s.empty()){
            sum += s.top();
            s.pop();
        }
        return sum;
    }
};
```

- 844.比较含退格的字符串

```c++
class Solution {
public:
    void transform(string S, stack<char> &s){
        for(int i = 0; i < S.size(); i++){
            if(S[i] == '#' && !s.empty()) s.pop();
            else if(S[i] != '#') s.push(S[i]);
        }
        return ;
    }
    bool backspaceCompare(string S, string T) {
		stack<char> s;
		stack<char> t;
        transform(S, s);
        transform(T, t);
        if(s.size() - t.size()) return false;
        while(!s.empty()){
            if(s.top() != t.top()) return false;
            s.pop(), t.pop();
        }
        return true;
    }
};
```

- 946.验证栈序列

只需关注出栈序列poppe即可，符合只有两种情况

①当前栈顶元素和要出栈元素相等

②未来有可能入栈

![](.\images\946.png)

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
		stack<int> s;
        for(int i = 0, j = 0; i < popped.size(); i++){
            while(j < pushed.size() && (s.empty() || s.top() != popped[i])){
                s.push(pushed[j]);
                j += 1;
            }
            if(s.top() != popped[i]) return false;
            s.pop();
        }
        return true;
    }
};
```

## 6.经典面试题-栈结构扩展

20.有效括号

```c++
class Solution {
public:
    bool isValid(string s) {
		stack<char> ss;
        for(int i = 0; i < s.size(); i++){
            switch(s[i]){
                case '(':
                case '[':
                case '{': ss.push(s[i]);break;
                case ')': if(ss.empty() || ss.top() != '(') return false; ss.pop(); break;
                case ']': if(ss.empty() || ss.top() != '[') return false; ss.pop(); break;
                case '}': if(ss.empty() || ss.top() != '{') return false; ss.pop(); break;
            }
        }
    	return ss.empty();
    }
};
```

- 1021删除最外层的括号

````c++
class Solution {
public:
    string removeOuterParentheses(string s) {
		string ret;
        // pre记录每一段独立括号的初始位置，cnt记录差值
        for(int i = 0, pre = 0, cnt = 0; i < s.size(); i++){
            if(s[i] == '(') cnt += 1;
            else cnt -= 1;
            if(cnt != 0)continue;
            ret += s.substr(pre + 1,i - pre - 1);
            pre = i + 1;
        }
        return ret;


````

- 1249移除无效的括号

 ```c++  
// 用栈的方式实现
class Solution {
public:
  string minRemoveToMakeValid(string s) {
	set<int> del;
      stack<int> ss;
      for(int i = 0; i < s.size(); i++){
          // 跳过多余元素
          if(s[i] - '(' && s[i] - ')') continue;
          if(s[i] == '(') ss.push(i);
          else{
              if(ss.empty()) del.insert(i);
              else ss.pop();
          }
      }
      // 多余的(
      while(!ss.empty()) del.insert(ss.top()), ss.pop();
      string ret;
      for(int i = 0; i < s.size(); i++){
          // set::find是C++ STL中的内置函数，该函数将迭代器返回到在集合容器中搜索的元素。如果找不到该元素，则迭代器将指向集合中最后一个元素之后的位置。
          if(del.find(i) != del.end()) continue;
          ret += s[i];
      }
      return ret;
  }
};
 ```

```c++
// 不用栈实现，先从前向后遍历，跳过多余的右括号，再从后向前遍历，跳过多余的左括号。
```

- 145二叉树的后序遍历

```c++
// 用迭代的方式去实现，模拟系统栈，还额外需要一个状态栈，记录程序需要做哪一步
// 规定 0 -> 放入左子树、1 -> 放入右子树、2 -> 输出根节点
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
		if (root == nullptr) return vector<int>();
        vector<int> ans;
        stack<TreeNode *> s1; // 递归过程中的局部变量
        stack<int> s2;
        s1.push(root);
        s2.push(0);
        while(!s1.empty()){
            int status = s2.top();
            s2.pop();
            switch (status) {
                case 0: {
                    s2.push(1);
                    if(s1.top()->left != nullptr){
                        s1.push(s1.top()->left);
                        s2.push(0);
                    }
                }break;
                case 1: {
                    s2.push(2);
                    if(s1.top()->right != nullptr){
                        s1.push(s1.top()->right);
                        s2.push(0);
                    }
                }break; 
                case 2: {
                    ans.push_back(s1.top()->val);
                    s1.pop();
                }break; 
            }
        }
        return ans;
    }
};
```

- 331验证二叉树的前序序列化

![](.\images\331.png)

```c++
class Solution {
public:
    bool isValidSerialization(string preorder) {
		vector<string> s;
        for(int i = 0, j = 0; i < preorder.size(); i = j + 1){
            // 下面3行是c++在处理逗号，每次j需要从i开始找逗号
			j = i;
            while(j < preorder.size() && preorder[j] != ',') ++j;
            s.push_back(preorder.substr(i, j - i));
            int last = s.size() - 1;
            while(s.size() >= 3 && s[last] == "#" && s[last - 1] == "#" && s[last - 2] != "#"){
                s[last - 2] = "#";
                s.pop_back();
                s.pop_back();
                // 重新定位最后一位元素
                last = s.size() - 1;
            }
        }
        return s.size() == 1 && s[0] == "#";
    }
};
```

- 227.基本计数器Ⅱ

```c++
// 用双栈依次把操作数和运算符依次压入栈中，然后当当前压入的运算符优先级小于栈顶元素运算符优先级时，得把前面运算符得运算结果先计算了
class Solution {
public:
    int level(char c){
        switch(c){
            case '@': return -1;
            case '+':
            case '-': return 1;
            case '*':
            case '/': return 2;
        }
        return 0;
    }
    int calc(int a, char op, int b){
        switch(op){
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b; 
        }
        return 0;
    }
    int calculate(string s) {
		stack<int> num;
		stack<char> ops;
        // 因为代码逻辑是碰到低优先级运算符就会计算前面的，所以多加一个优先级最低的符号执行最后的计算
        s += "@";
        for(int i = 0, n = 0; i < s.size(); i++){
            if(s[i] == ' ')continue;
            if(level(s[i]) == 0){
                n = n * 10 + (s[i] - '0');
                continue;
            }
            num.push(n);
            n = 0;
            while(!ops.empty() && level(s[i]) <= level(ops.top())){
                int b = num.top(); num.pop();
                int a = num.top(); num.pop();
                num.push(calc(a, ops.top(), b));
                ops.pop();
            }
            ops.push(s[i]);
        }
        return num.top();
    }
};
```

- 636函数的独占时间

```c++
class Solution {
public:
    vector<int> exclusiveTime(int n, vector<string>& logs) {
		vector<int> ans(n);
        stack<int> vID;
        for(int i = 0, pre = 0; i < logs.size(); i++){
            int pos1 = logs[i].find_first_of(":");
            int pos2 = logs[i].find_last_of(":");
            string id_str = logs[i].substr(0, pos1);
            string status = logs[i].substr(pos1 + 1, pos2 - pos1 - 1);
            string time_str = logs[i].substr(pos2 + 1, logs[i].size());
            int id = atoi(id_str.c_str());
            int time_stamp = atoi(time_str.c_str());
            if(!vID.empty()) ans[vID.top()] += time_stamp - pre + (status == "end");
            pre = time_stamp + (status == "end");
            if(status == "start") vID.push(id);
            else vID.pop();
            /*
            if(status == "start"){
                if(!vID.empty()){
                    ans[vID.top()] += time_stamp - pre;
                }
                pre = time_stamp;
                vID.push(id);
            }else{
                ans[vID.top()] += time_stamp - pre + 1;
                pre = time_stamp + 1;
                vID.pop();
            } 
            */
        }
        return ans;
    }
};
```

- 1124.表现良好的最长时间段

编程技巧前缀和数组：把前i项相加之和得到的结果组成数组；好处：可以帮助我们快速的计算原序列的区间和

![](.\images\1124.png)

```c++
class Solution {
public:
    int longestWPI(vector<int>& hours) {
        // 前缀和中每一个值第一次出现的位置
		unordered_map<int, int> ind;
        // 记录每个值的第一次出现时最长长度，因为初始值是0，所以负数会被置为0
		unordered_map<int, int> f;
        ind[0] = -1;
        f[0] = 0;
        // cnt前缀和
        int cnt = 0, ans = 0;
        for(int i = 0; i < hours.size(); i++){
            if(hours[i] > 8) cnt += 1;
            else cnt -= 1;
            if(ind.find(cnt) == ind.end()){
                ind[cnt] = i;
                if(ind.find(cnt - 1) == ind.end()) f[cnt] = 0;
                else f[cnt] = f[cnt - 1] + (i - ind[cnt - 1]);
            }
            if(ind.find(cnt - 1) == ind.end()) continue;
            ans = max(ans, i - ind[cnt - 1] + f[cnt - 1]);
        }
        return ans;
    }
};
```

# 四.二叉树

## 1.基本知识

![](.\images\树结构定义.png)

![](.\images\二叉树.png)

说明：几度就是有几个孩子

![](.\images\前序遍历.png)

![](.\images\中序遍历.png)

![](.\images\后序遍历.png)

中+前/后 可以还原一颗二叉树

![](.\images\还原二叉树.png)

完全二叉树：在最后一层的右侧缺少节点的二叉树

满二叉树：没有度为1的节点

完美二叉树：每一层都满了的二叉树

![](.\images\二叉树正确版.jpg)

**完全二叉树**（有价值）

![](.\images\完全二叉树.jpg)

关于树结构的深入理解

树的节点代表集合，树的边代表关系，可以总结出父节点和子节点间的关系，父节点代表全集，子节点代表父节点互不相交的子集。

集合涉及到的问题最核心之一是查找，所以树结构最主要的作用就是应用于各种场景下的查找操作

## 2.学习二叉树的作用

(1)二叉树的作用一

![](.\images\二叉树的作用一.png)

(2).二叉树的作用二

![](.\images\二叉树的作用二.png)

二叉树的作用二举例.png

![](.\images\二叉树的作用二举例.png)

(3).二叉树的作用三

<img src=".\images\左孩子右兄弟.png" style="zoom:50%;" />

![](.\images\二叉树作用三.png)

## 3.经典面试题-二叉树的基本操作

- 144二叉树的前序遍历

```c++
class Solution {
public:
    void preorder(TreeNode *root,vector<int> &ans){
        if(root == NULL)return;
        ans.push_back(root->val);
        preorder(root->left, ans);
        preorder(root->right, ans);
        return;
    }
    vector<int> preorderTraversal(TreeNode* root) {
		vector<int> ans;
        preorder(root, ans);
        return ans;
    }
};
```

- 589 N叉树的前序遍历

```c++
class Solution {
public:
    void __preorder(Node *root,vector<int> &ans){
        if(root == NULL)return;
        ans.push_back(root->val);
        for(auto x : root->children){
        	__preorder(x, ans);
        }
        return;
    }
    vector<int> preorder(Node* root) {
		vector<int> ans;
        __preorder(root, ans);
        return ans;
    }
};
```

- 226翻转二叉树

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
		if(root == NULL) return root;
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

- 剑指offer32.从上到下打印二叉树Ⅱ

```c++
class Solution {
public:
    void getResult(TreeNode *root, int k, vector<vector<int>> &ans){
        if(root == NULL) return;
        if(k == ans.size()) ans.push_back(vector<int>());
        ans[k].push_back(root->val);
        getResult(root->left, k + 1, ans);
        getResult(root->right, k + 1, ans);
        return;
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
		vector<vector<int>> ans;
        getResult(root, 0, ans);
        return ans;
    }
};
```

- 107.二叉树的层序遍历Ⅱ

```c++
class Solution {
public:
    void getResult(TreeNode *root, int k, vector<vector<int>> &ans){
        if(root == NULL) return;
        if(k == ans.size()) ans.push_back(vector<int>());
        ans[k].push_back(root->val);
        getResult(root->left, k + 1, ans);
        getResult(root->right, k + 1, ans);
        return;
    }
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
		vector<vector<int>> ans;
        getResult(root, 0, ans);
        for (int i = 0, j = ans.size() - 1; i < j; i++, j--){
            swap(ans[i], ans[j]);
        }
        return ans;
    }
};
```

- 103.二叉树的锯齿形层序遍历

```c++
class Solution {
public:
    void getResult(TreeNode *root, int k, vector<vector<int>> &ans){
        if(root == NULL) return;
        if(k == ans.size()) ans.push_back(vector<int>());
        ans[k].push_back(root->val);
        getResult(root->left, k + 1, ans);
        getResult(root->right, k + 1, ans);
        return;
    }
    void reverse(vector<int> &ans){
        for (int i = 0, j = ans.size() - 1; i < j; i++, j--){
            swap(ans[i], ans[j]);
        }
    }
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
		vector<vector<int>> ans;
        getResult(root, 0, ans);
        for(int i = 1; i < ans.size(); i += 2){
            reverse(ans[i]);
        }
        return ans;
    }
};
```

- 110.	平衡二叉树

```c++
class Solution {
public:
    /*
    获取树高的方法
    int getHeight(TreeNode *root){
        if(root == NULL) return 0;
        int l = getHeight(root->left);
        int r = getHeight(root->right);
        return max(l, r) + 1;
    }
    */
    int getHeight(TreeNode *root){
        if(root == NULL) return 0;
        int l = getHeight(root->left);
        int r = getHeight(root->right);
        // 当有子节点已经不平衡时，也返回-2；
        if(l < 0 || r < 0) return -1;
        if(abs(l - r) > 1) return -1;
        return max(l, r) + 1;
    }
    bool isBalanced(TreeNode* root) {
		return getHeight(root) >= 0;
    }
};
```

- 112.路径总和

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
		if(root == NULL) return false;
        if(root->left == NULL && root->right == NULL) return root->val == targetSum;
        if(root->left && hasPathSum(root->left, targetSum - root->val)) return true;
        if(root->right && hasPathSum(root->right, targetSum - root->val)) return true;
        return false;
        
    }
};
```

- 105.从前序与中序遍历序列构造二叉树

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		if(preorder.size() == 0) return NULL;
        int pos = 0;
        while(inorder[pos] != preorder[0]) ++pos;
        vector<int> l_pre, l_in, r_pre, r_in;
        for(int i = 0; i < pos; i++){
            l_pre.push_back(preorder[i+1]);
            l_in.push_back(inorder[i]);  
        }
        for(int i = pos + 1; i < preorder.size(); i++){
            r_pre.push_back(preorder[i]);
            r_in.push_back(inorder[i]);  
        }
        TreeNode *root = new TreeNode(preorder[0]);
        root->left = buildTree(l_pre,l_in);
        root->right = buildTree(r_pre,r_in);
        return root;
    }
};
```



- 222.完全二叉树的节点个数

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
		if(root == NULL) return 0;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

- 剑指 Offer 54. 二叉搜索树的第k大节点

二叉搜索树：右子树上的值都要大于根节点，左子树上的值都要小于根节点。

特点：中序遍历的结果就是一个有序序列

```c++
class Solution {
public:
    int getCount(TreeNode *root) {
		if(root == NULL) return 0;
        return getCount(root->left) + getCount(root->right) + 1;
    }
    int kthLargest(TreeNode* root, int k) {
		int cnt_r = getCount(root->right);
        if(k <= cnt_r) return kthLargest(root->right, k);
        if(k == cnt_r + 1) return root->val;
        return kthLargest(root->left, k - cnt_r - 1);
    }
};
```

```c++
// 简单实现中序遍历后找第k大
class Solution {
public:
    void in_order(TreeNode *root, vector<int> &ans) {
		if(root == NULL) return;
        in_order(root->left, ans);
        ans.push_back(root->val);
        in_order(root->right, ans); 
        return;
    }
    int kthLargest(TreeNode* root, int k) {
		vector<int> ans;
        in_order(root, ans);
        return ans[ans.size() - k];
    }
};
```

- 剑指 Offer 26. 树的子结构

```c++
class Solution {
public:
    bool is_Match(TreeNode *A, TreeNode *B){
        // 走到B为空说明B至少是A的一部分
        if(B == NULL)return true;
        // B不为空A为空false
        if(A == NULL)return false;
        if(A->val != B->val)return false;
        return is_Match(A->left, B->left) && is_Match(A->right, B->right);
    }
    bool isSubStructure(TreeNode* A, TreeNode* B) {
		if(B == NULL) return false;
		if(A == NULL) return false;
        if(A->val == B->val && is_Match(A, B)) return true;
        return isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
};
```

- 662.二叉树最大宽度



```c++
class Solution {
public:
    typedef pair<TreeNode *, int> PNI;
    int widthOfBinaryTree(TreeNode* root) {
        int ans = 0;
        // 用队列处理每一行数据
		queue<PNI> q;
        q.push(PNI(root, 0));
        while(!q.empty()){
            int cnt = q.size();
            // l为当前行最小编号，r为最大编号
            int l = q.front().second, r = q.front().second;
            for(int i = 0; i < cnt; i++){
                TreeNode *n = q.front().first;
                int ind = q.front().second;
                r = ind;
                // 运用了完美二叉树的编号技巧
                // 节点编号为（父节点-父所在行最小编号）*2，以后看不懂看视频多看
                if(n->left) q.push(PNI(n->left, (ind - l)*2));
                if(n->right) q.push(PNI(n->right, (ind - l)*2 + 1));
                q.pop();
            }
            ans = max(ans, r - l +1);
        }
        return ans;
    }
};
```

![](.\images\662.jpg)

- 968.监控二叉树

```c++
class Solution {
public:
    void getDP(TreeNode *root, int dp[2][2]){
        if(root == NULL){
            dp[0][0] = 0;
            dp[0][1] = 10000;
            dp[1][0] = 0;
            dp[1][1] = 10000;
            return;
        }
        if(root->left == NULL && root->right == NULL){
            dp[0][0] = 10000;
            dp[0][1] = 1;
            dp[1][0] = 0;
            dp[1][1] = 1;
            return;
        }
        int l[2][2], r[2][2];
        getDP(root->left, l);
        getDP(root->right, r);
        dp[0][0] = min(min(l[0][1] + r[0][0] ,l[0][0] + r[0][1]), l[0][1] + r[0][1]);
        dp[1][0] = min(dp[0][0], l[0][0] + r[0][0]);
        dp[0][1] = min(min(l[1][0] + r[1][0] ,l[1][1] + r[1][1]), min(l[1][0] + r[1][1] ,l[1][1] + r[1][0])) + 1;
        dp[1][1] = dp[0][1];
        
    }
    int minCameraCover(TreeNode* root) {
		int dp[2][2];
        getDP(root, dp);
        return min(dp[0][1], dp[0][0]);
    }
};
```

# 五.堆与优先队列

## 1.堆的基础知识

(1)**数据结构**：**结构定义**（结构（基于完全二叉树）+结构性质（大顶堆、小顶堆）） + **结构操作**（维护这种结构性质），**总结数据结构就是定义一种性质，并且维护这种性质**

(2)大顶堆：任意的一个三元组之间，父节点都要大于两个子节点

(3)结构操作

①尾部插入调整：先在末尾插入，再向上调整

②头部弹出调整：弹出头部元素，把尾部元素放入头部，再向下调整

③堆排序

口诀

- 将堆顶元素与堆尾元素交换
- 将此操作看作是堆顶元素弹出操作
- 按照头部弹出以后的策略调整堆
- 执行n次

(4)优先队列

堆是优先队列的一种实现方式

![](.\images\优先队列.png)

## 2.堆的代码实现

```c++
#define Max_N 1000
int data[Max_N + 5], cnt = 0;

int top(){ return data[0];}
int size(){ return cnt;}

void push(int x){
    data[cnt++] = x;
    int ind = cnt - 1;
    // 左右节点获取父节点的下标都是(ind - 1) / 2
    while(ind && data[(ind - 1) / 2] < data[ind]){
        swap(data[(ind - 1) / 2], data[ind]);
        ind = (ind - 1) / 2;
    }
    return;
}
void pop(){
    if(size() == 0) return;
    data[0] = data[cnt - 1];
    cnt -= 1;
    int ind = 0; n = cnt - 1;
    while(ind * 2 + 1 <= n){
        int temp = ind;
        if(data[temp] < data[ind * 2 + 1]) temp = ind * 2 + 1;
        if(ind * 2 + 2 <= n && data[temp] < data[ind * 2 + 2]) temp = ind * 2 + 2;
        if(temp == ind)break;
        swap(data[temp], data[ind]);
        ind = temp;
    }
    
}
```

```c++
// 实现的漂亮点
#define Max_N 1000
int data[Max_N + 5], cnt = 0;

int top(){ return data[0];}
int size(){ return cnt;}

void shift_up(int ind){
    // 左右节点获取父节点的下标都是(ind - 1) / 2
    while(ind && data[(ind - 1) / 2] < data[ind]){
        swap(data[(ind - 1) / 2], data[ind]);
        ind = (ind - 1) / 2;
    }
    return;
}

void shift_down(int ind){
    int n = cnt -1;
    while(ind * 2 + 1 <= n){
        int temp = ind;
        if(data[temp] < data[ind * 2 + 1]) temp = ind * 2 + 1;
        if(ind * 2 + 2 <= n && data[temp] < data[ind * 2 + 2]) temp = ind * 2 + 2;
        if(temp == ind)break;
        swap(data[temp], data[ind]);
        ind = temp;
    }
    return;
}

void push(int x){
    data[cnt++] = x;
    shift_up(cnt - 1);
    return;
}
void pop(){
    if(size() == 0) return;
    // 排序，赋值改成交换
    swap(data[0], data[cnt - 1]);
    cnt -= 1;
    shift_down(0);
    return;
}

void output(int n){
    printf("heap : ");
    for(int i = 0; i < n; i++){
        printf("%d ", data[i]);
    }
    printf("\n");
    return;
}

int main(){
    int op, val;
    // 记录最大树节点数量，查看堆排序结果
    int max_n = 0;
    while(cin >> op){
        switch(op){
            case 0:{
                cin >> val;
                printf("push %d to heap\n", val);
                push(val);
            }break;
            case 1:{
                printf("push %d to heap\n", top());
                pop();
            }break;
            case 2:{
                // 输出堆排序后data中中的值
                output(max_n);
            }break;
        }
        max_n = max(cnt, max_n);
    	output(cnt);
    }
    return 0;
}
```

## 3.经典面试题-堆的基础应用

一句话理解：堆

堆适合维护：集合最值

- 剑指 Offer 40. 最小的k个数

```c++
class Solution {
public:
    // 用c++的语法实现了一个堆，传less<int>()代表大顶堆，传greater<int>()代表小顶堆
    template<typename T>
    class Heap: public vector<T>{
    public:
        template<typename Func_T>
        Heap(Func_T cmp) : cmp(cmp) {}
        void push(const T &a){
            this->push_back(a);
            push_heap(this->begin(), this->end(), cmp);
            return;
        }
        void pop(){
            pop_heap(this->begin(), this->end(), cmp);
            this->pop_back();
            return;
        }
        T &top() {return this->at(0);}
    private:
        function<bool(T, T)> cmp;
    };
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
		Heap<int> h{less<int>()};
        for(auto x : arr){
            h.push(x);
            if(h.size() > k)h.pop();
        }
        return h;
    }
};
```

- 1046.最后一块石头的重量

```c++
class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
		Heap<int> h{less<int>()};
        for(auto x : stones){
            h.push(x);
        }
        while(h.size() > 1){
            int y = h.top(); h.pop();
            int x = h.top(); h.pop();
            if(x == y) continue;
            h.push(y - x);
        }
        if(h.size() == 0) return 0;
        return h.top();
    }
};
```

- 703.数据流中的第 K 大元素

```c++
class KthLargest {
public:
    Heap<int> h{greater<int>()};
    int k;
    KthLargest(int k, vector<int>& nums) : k(k) {
		for(auto x : nums){
            add(x);
        }
        return;
    }
    
    int add(int val) {
		h.push(val);
        if(h.size() > k) h.pop();
        return h.top();
    }
};

```

- 215.数组中的第K个最大元素

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
		Heap<int> h{greater<int>()};
        for(auto x : nums){
            h.push(x);
            if(h.size() > k)h.pop();
        }
        return h.top();
    }
};
```

- 373.查找和最小的K对数字

```c++
class Solution {
public:
    struct CMP{
        bool operator()(vector<int> a, vector<int> b){
            return a[0] + a[1] < b[0] + b[1];
        }
    }
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        // 创造了一个大顶堆
        CMP less_than;
		Heap<vector<int>> h{less_than};
        vector<int> temp(2);
        for(auto x : nums1){
        	for(auto y : nums2){
                temp[0] = x, temp[1] = y;
                // 长度小于k前直接放入，这是代码优化，不然会超出时间限制
                if(h.size() < k || less_than(temp, h.top())){
                	h.push(temp);
            		if(h.size() > k) h.pop(); 
                }else{
                    break;
                }	
        	}  
        }
        return h;    
    }
};
```

- 692.前K个高频单词

```c++
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
		unordered_map<string, int>freq;
        for(auto x : words) freq[x] += 1;
        auto cmp = [&freq](string a, string b) -> bool {
            if(freq[a] - freq[b]) return freq[a] > freq[b];
            return a < b;
        };
        Heap<string> h{cmp};
        for(auto x : freq){
            h.push(x.first);
            if(h.size() >k) h.pop();
        }
        sort(h.begin(), h.end(), cmp);
        return h;
    }
};
```

- 295.数据流的中位数 / 面试题 17.20. 连续中值

![](.\images\295.jpg)

```c++
class MedianFinder {
public:
    template<typename T>
    class Heap: public vector<T>{
    public:
        template<typename Func_T>
        Heap(Func_T cmp) : cmp(cmp) {}
        void push(const T &a){
            this->push_back(a);
            push_heap(this->begin(), this->end(), cmp);
            return;
        }
        T pop(){
            T ret = top();
            pop_heap(this->begin(), this->end(), cmp);
            this->pop_back();
            return ret;
        }
        T &top() {return this->at(0);}
    private:
        function<bool(T, T)> cmp;
    };
    Heap<int> h1, h2;
    MedianFinder() : h1{less<int>()}, h2{greater<int>()}{}
    
    void addNum(int num) {
		if(h1.size() == 0 || num <= h1.top()){
            h1.push(num);
        }else{
            h2.push(num);
        }
        if(h2.size() > h1.size()){
            h1.push(h2.pop());
        }
        if(h1.size() == h2.size() + 2){
            h2.push(h1.pop());
        }
        return;
    }
    
    double findMedian() {
		int n = h1.size() + h2.size();
        if(n % 2 == 1){
            return h1.top();
        }
        return 1.0 * (h1.top() + h2.top()) / 2;
    }
};
```

- 264.丑数 II

![](.\images\264.png)

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        Heap<long long> h{greater<long long>()};
        long long ans = 0;
        h.push(1);
		while(n--){
            ans = h.top();
            h.pop();
            if(ans % 5 == 0){
                h.push(ans * 5);
            }else if(ans % 3 == 0){
                h.push(ans * 5);
                h.push(ans * 3);
            }else{
                h.push(ans * 5);
                h.push(ans * 3);
                h.push(ans * 2);
            }
        }
        return ans;
    }
};
```

- 313.超级丑数

```c++
// 超出时间限制，老师能通过
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
		vector<int> p(primes.size());
        vector<int> data;
        data.push_back(1);
        int ans = 1;
        while(data.size() != n){
            ans = primes[0] * data[p[0]];
            for(int i = 1; i < primes.size(); i++){
                ans = min(ans, primes[i] * data[p[i]]);
            }
            for(int i = 0; i < primes.size(); i++){
                if(primes[i] * data[p[i]] == ans) p[i]++;
            }
            data.push_back(ans);
        }
        return ans;
    }
};
```

- 1753.移除石子的最大得分

![](.\images\1753.png)

```c++
class Solution {
public:
    int maximumScore(int a, int b, int c) {
		if(a > b)swap(a, b);
		if(a > c)swap(a, c);
		if(b > c)swap(b, c);
        int ans = 0;
        // step1
        int cnt1 = min(a, c - b);
        a -= cnt1;
        c -= cnt1;
        ans += cnt1;
        // step2
        if(a != 0){
        	if(a % 2 == 1) a -= 1;
            b -= a / 2;
            c -= a / 2;
            ans += a;
        }
        // step3
        ans += b;
        return ans;
    }
};
```

- 1801.积压订单中的订单总数

```c++
class Solution {
public:
    struct CMP1{
        bool operator()(vector<int> a, vector<int> b){
            return a[0] < b[0];
        }
    };
    struct CMP2{
        bool operator()(vector<int> a, vector<int> b){
            return a[0] > b[0];
        }
    };
    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
		Heap<vector<int>>buy{CMP1()}, sell{CMP2()};
        for(auto x : orders){
            if(x[2] == 0){
                while(x[1] != 0 && sell.size() && sell[0][0] <= x[0]){
                    int cnt = min(x[1], sell[0][1]);
                    x[1] -= cnt;
                    sell[0][1] -= cnt;
                    if(sell[0][1] == 0) sell.pop();
                }
                if(x[1] != 0) buy.push(x);
            }else{
                while(x[1] != 0 && buy.size() && buy[0][0] >= x[0]){
                    int cnt = min(x[1], buy[0][1]);
                    x[1] -= cnt;
                    buy[0][1] -= cnt;
                    if(buy[0][1] == 0) buy.pop();
                }
                if(x[1] != 0) sell.push(x);
            }
        }
        int sum = 0;
        int mod = 1000000007;
        for(auto x : buy){
            sum = (sum + x[1]) % mod;
        }
        for(auto x : sell){
            sum = (sum + x[1]) % mod;
        }
        return sum;
    }
};
```

# 六.并查集及经典问题

## 1.并查集的基础知识

(1)并查集解决连通性问题

需要维护连通关系，或者查询连通关系的问题场景，适合用并查集。

连通性性质：传递性

百变大咖：并查集

并查集是一类抽象化程度很高的数据结构

(2)Quick-Find算法

![](.\images\Quick-Find.jpg)

![](.\images\Quick-Find总结.png)

```c++
// 实现Quick-Find：查找起来快
class UnionSet {
public:
    int *color, n;
    UnionSet(int n) : n(n) {
        color = new int[n + 1];
        for(int i = 0; i <= n; i++){
            color[i] = i;
        }
    }
    int find(int x){
        return color[x];
    }
    void merge(int a, int b){
        if(color[a] == color[b]) return;
        int cb = color[b];
        for(int i = 0; i <= n; i++){
            if(color[i] == cb) color[i] = color[a];
        }
    }
};
```

(3)Quick-Union

```c++
// 实现
class UnionSet {
public:
    int *boss, n;
    UnionSet(int n) : n(n) {
        boss = new int[n + 1];
        for(int i = 0; i <= n; i++){
            boss[i] = i;
        }
    }
    int find(int x){
        if(boss[x] == x) return x;
        return find(boss[x]);
    }
    void merge(int a, int b){
        int fa = find(a), fb = find(b);
        if(fa == fb) return;
        boss[fa] = fb;
        return;
    }
};
```

按质优化：根据指标，平均查找次数，推导得出谁的节点少，谁当儿子

sa,sb节点数量、la,lb总查找次数

![](.\images\Quick-Union.png)

(4)Weighted_Quick-Union

```c++
// 优化后实现
class UnionSet {
public:
    int *fa, *size, n;
    UnionSet(int n) : n(n) {
        fa = new int[n + 1];
        size = new int[n + 1];
        for(int i = 0; i <= n; i++){
            fa[i] = i;
            size[i] = 1;
        }
    }
    int find(int x){
        if(fa[x] == x) return x;
        return find(fa[x]);
    }
    void merge(int a, int b){
        int ra = find(a), rb = find(b);
        if(ra == rb) return;
        if(size[ra] < size[rb]){
            fa[ra] = rb;
            size[rb] += size[ra];
        }else{
            fa[rb] = ra;
            size[ra] += size[rb];
        }
        return;
    }
};
```

(4)Weighted-Quick-Union-pc(路径压缩优化)

```c++
class UnionSet {
public:
    int *fa, *size, n;
    UnionSet(int n) : n(n) {
        fa = new int[n + 1];
        size = new int[n + 1];
        for(int i = 0; i <= n; i++){
            fa[i] = i;
            size[i] = 1;
        }
    }
    int find(int x){
        if(fa[x] == x) return x;
        int root = find(fa[x]);
        fa[x] = root;
        return root;
    }
    void merge(int a, int b){
        int ra = find(a), rb = find(b);
        if(ra == rb) return;
        if(size[ra] < size[rb]){
            fa[ra] = rb;
            size[rb] += size[ra];
        }else{
            fa[rb] = ra;
            size[ra] += size[rb];
        }
        return;
    }
};
```

(5)Quick-Union-pc(只有路径压缩优化)

```c++
class UnionSet {
public:
    int *fa, n;
    UnionSet(int n) : n(n) {
        fa = new int[n + 1];
        for(int i = 0; i <= n; i++){
            fa[i] = i;
        }
    }
    int find(int x){
        if(fa[x] == x) return x;
        int root = find(fa[x]);
        fa[x] = root;
        return root;
    }
    void merge(int a, int b){
        int ra = find(a), rb = find(b);
        if(ra == rb) return;
        fa[ra] = rb;
        return;
    }
};
```

(6)解题时用的标准化的并查集基础类

```c++
class UnionSet {
public:
    int *fa, n;
    UnionSet(int n) : n(n) {
        fa = new int[n + 1];
        for(int i = 0; i <= n; i++){
            fa[i] = i;
        }
    }
    int get(int x){
        return fa[x] = (fa[x] == x ? x : get(fa[x]));
    }
    void merge(int a, int b){
        fa[get(a)] = get(b);
    }
};
```

## 2.经典面试题-并查集基础题目

- 547.省份数量

```c++
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
		int n = isConnected.size();
        UnionSet u(n);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                if(isConnected[i][j]) u.merge(i, j);
            }
        }
        int ans = 0;
        for(int i = 0; i < n; i++){
            if(u.get(i) == i) ans +=1;
        }
        return ans;
    }
};
```

- 200.岛屿数量

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
		int n = grid.size(), m = grid[0].size();
        UnionSet u(n * m);
        #define ind(i,  j) ((i) * m + (j))
        for (int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == '0') continue;
                if(i > 0 && grid[i - 1][j] == '1') u.merge(ind(i, j), ind(i - 1,j));
                if(j > 0 && grid[i][j - 1] == '1') u.merge(ind(i, j), ind(i,j - 1));
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == '1' && u.get(ind(i, j)) == ind(i, j)) ans += 1;
            }
        }
        #undef ind
        return ans;
    }
};
```

- 990.等式方程的可满足性

```c++
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
		UnionSet u(26);
        for(auto s : equations){
            if(s[1] == '!') continue;
            int a = s[0] - 'a';
            int b = s[3] - 'a';
            u.merge(a, b);
        }
        for(auto s : equations){
            if(s[1] == '=') continue;
            int a = s[0] - 'a';
            int b = s[3] - 'a';
            if(u.get(a) == u.get(b)) return false;
        }
        return true;
    }
};
```

- 684.冗余连接

```c++
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
		UnionSet u(edges.size());
        for(auto e : edges){
            int a = e[0];
            int b = e[1];
            if(u.get(a) == u.get(b)) return e;
            u.merge(a, b);
        }
        return vector<int>();
    }
};
```

- 1319.连通网络的操作次数

```c++
class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
		if(connections.size() < n - 1) return -1;
        UnionSet u(n);
        for(auto e : connections){
            int a = e[0];
            int b = e[1];
            u.merge(a, b);
        }
        int cnt = 0;
        for(int i = 0; i < n; i++){
            if(u.get(i) == i) cnt += 1;
        }
        return cnt - 1;
    }
};
```

- 128.最长连续序列

```c++
class Solution {
public:
    class UnionSet {
    public:
        int *fa, *cnt, n;
        UnionSet(int n) : n(n) {
            fa = new int[n + 1];
            cnt = new int[n + 1];
            for(int i = 0; i <= n; i++){
                fa[i] = i;
                cnt[i] = 1;
            }
        }
        int get(int x){
            return fa[x] = (fa[x] == x ? x : get(fa[x]));
        }
        void merge(int a, int b){
            if(get(a) == get(b)) return;
            cnt[get(b)] += cnt[get(a)];
            fa[get(a)] = get(b);
            return;
        }
    };
    int longestConsecutive(vector<int>& nums) {
		unordered_map<int, int> ind;
        // 连接时连接数字的下标，因为数字有可能很大
        UnionSet u(nums.size());
        for(int i = 0; i < nums.size(); i++){
            int x = nums[i];
            if(ind.find(x) != ind.end()) continue;
            if(ind.find(x - 1) != ind.end()){
                u.merge(i, ind[x - 1]);
            }
            if(ind.find(x + 1) != ind.end()){
                u.merge(i, ind[x + 1]);
            }
            ind[x] = i;
        }
        int ans = 0;
        for(int i = 0; i < nums.size(); i++){
            if(u.get(i) == i && u.cnt[i] > ans) ans = u.cnt[i];
        }
        return ans;
    }
};
```

- 947.移除最多的同行或同列石头

```c++
class Solution {
public:
    int removeStones(vector<vector<int>>& stones) {
        UnionSet u(stones.size());
		unordered_map<int, int> ind_x, ind_y;
        for(int i = 0; i < stones.size(); i++){
            int x = stones[i][0];
            int y = stones[i][1];
            if(ind_x.find(x) != ind_x.end()){
                u.merge(i, ind_x[x]);
            }
            if(ind_y.find(y) != ind_y.end()){
                u.merge(i, ind_y[y]);
            }
            ind_x[x] = i;
            ind_y[y] = i;
        }
        int cnt = 0;
        for(int i = 0; i < stones.size(); i++){
            if(u.get(i) == i) cnt += 1;
        }
        return stones.size() - cnt;
    }
};
```

- 1202.交换字符串中的元素

```c++
class Solution {
public:
    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
		UnionSet u(s.size());
        priority_queue<char, vector<char>, greater<char>> h[s.size()];
        for(auto p : pairs){
            int i = p[0];
            int j = p[1];
            u.merge(i, j);
        }
        for(int i = 0; i < s.size(); i++){
            h[u.get(i)].push(s[i]);
        }
        string ret = "";
        for(int i = 0; i < s.size(); i++){
            ret += h[u.get(i)].top();
            h[u.get(i)].pop();
        }
        return ret;
    }
};
```

# 七.快速排序（Quick-Sort）及优化

## 1.快速排序的基础知识

普通的快速排序，取左边第一位数值为基准值

这种在熵很低的情况下，效率并不高

```c++
void quick_sort_v1(int *arr, int l,int r){
    if(l >= r) return;
    int x = l, y = r,base = arr[l];
    while(x < y){
        while(x < y && arr[y] >= base) y--;
        if(x < y) arr[x++] = arr[y];
        while(x < y && arr[x] < base) x++;
        if(x < y) arr[y--] = arr[x];
    }
    arr[x] = base;
    quick_sort_v1(arr, l, x - 1);
    quick_sort_v1(arr, x + 1, r);
    return;
}
```

从C++ STL学习快速排序

1.单边递归法

2.无监督partition方法（取消边界判定）

3.三点取中法

4.小数据规模，停止快排过程

5.使用插入排序进行首尾

```c++
// 左递归法：右边用递归，左边用循环
void quick_sort_v2(int *arr, int l,int r){
    while(l < r){
        int x = l, y = r,base = arr[l];
        while(x < y){
            while(x < y && arr[y] >= base) y--;
            if(x < y) arr[x++] = arr[y];
            while(x < y && arr[x] < base) x++;
            if(x < y) arr[y--] = arr[x];
        }
        arr[x] = base;
        quick_sort_v2(arr, x + 1, r);
        r = x - 1;
    }
    return;
}
```

```c++
const int threshold = 16;
inline int getmid(int a, int b, int c){
    if(a > b) swap(a, b);
    if(a > c) swap(a, c);
    if(b > c) swap(b, c);
    return b;
}

void __quick_sort_v3(int *arr, int l,int r){
    while(r - l > threshold){
        int x = l, y = r,base = getmid(arr[l], arr[(l + r) / 2], arr[r]);
        do{
            while(arr[x] < base) x++;
            while(arr[y] > base) y--;
            if(x <= y){
            	swap(arr[x], arr[y]);
                x++, y--;
            }
        }while(x <= y);
        __quick_sort_v3(arr, x, r);
        r = y;
    }
    return;
}

void final_insert_sort(int *arr, int l, int r){
    int ind = l;
    for(int i = l + 1; i <= r; i++){
        if(arr[i] < arr[ind]) ind = i;
    }
    while(ind > l){
        swap(arr[ind], arr[ind - 1]);
        ind--;
    }
    for(int i = l + 2; i <= r; i++){
        int j = i;
        while(arr[j] < arr[j - 1]){
            swap(arr[j], arr[j - 1]);
            j--;
        }
    }
    return;
}

void quick_sort_v3(int *arr, int l,int r){
    __quick_sort_v3(arr, l, r);
    final_insert_sort(arr, l, r);
}
```

## 2.快速排序扩展算法-快速排序、经典面试题-快速排序基础

用来快速查找排名第k位的元素

- 912.排序数组

```c++
// 普通快排，会超出时间限制
class Solution {
public:
    void quick_sort_v1(vector<int> &arr, int l,int r){
        if(l >= r) return;
        int x = l, y = r,base = arr[l];
        while(x < y){
            while(x < y && arr[y] >= base) y--;
            if(x < y) arr[x++] = arr[y];
            while(x < y && arr[x] < base) x++;
            if(x < y) arr[y--] = arr[x];
        }
        arr[x] = base;
        quick_sort_v1(arr, l, x - 1);
        quick_sort_v1(arr, x + 1, r);
        return;
    }
    vector<int> sortArray(vector<int>& nums) {
        quick_sort_v1(nums,0,nums.size() - 1);
        return nums;
    }
};
```

```c++
class Solution {
public:
    const int threshold = 16;
    inline int getmid(int a, int b, int c){
        if(a > b) swap(a, b);
        if(a > c) swap(a, c);
        if(b > c) swap(b, c);
        return b;
    }

    void __quick_sort_v3(vector<int> &arr, int l,int r){
        while(r - l > threshold){
            int x = l, y = r,base = getmid(arr[l], arr[(l + r) / 2], arr[r]);
            do{
                while(arr[x] < base) x++;
                while(arr[y] > base) y--;
                if(x <= y){
                    swap(arr[x], arr[y]);
                    x++, y--;
                }
            }while(x <= y);
            __quick_sort_v3(arr, x, r);
            r = y;
        }
        return;
    }

    void final_insert_sort(vector<int> &arr, int l, int r){
        int ind = l;
        for(int i = l + 1; i <= r; i++){
            if(arr[i] < arr[ind]) ind = i;
        }
        while(ind > l){
            swap(arr[ind], arr[ind - 1]);
            ind--;
        }
        for(int i = l + 2; i <= r; i++){
            int j = i;
            while(arr[j] < arr[j - 1]){
                swap(arr[j], arr[j - 1]);
                j--;
            }
        }
        return;
    }

    void quick_sort_v3(vector<int> &arr, int l,int r){
        __quick_sort_v3(arr, l, r);
        final_insert_sort(arr, l, r);
    }
    vector<int> sortArray(vector<int>& nums) {
        quick_sort_v3(nums,0,nums.size() - 1);
        return nums;
    }
};
```

- 剑指Offer21.调整数组顺序使奇数位于偶数前面

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        if(num.size() == 0) return nums;
        int x = 0, y = nums.size() - 1;
        do{
            while(x < y && nums[x] % 2) x++;
            while(x < y && nums[y] % 2 == 0) y--;
            if(x < y){
                swap(nums[x], nums[y]);
                x++, y--;
            }
        }while(x < y);
        return nums;
    }
};
```

- 148.排序链表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
		if(head == NULL) return head;
        int l = head->val, r = head->val;
        // int类型负数/2会变为正数，初始化为double
        double mid;
        // h1、h2需要初始化为NULL，不能存值，不然遍历时会把这两个假节点遍历进去（实验时下一行代码会报错）
        ListNode *p = head, *q, *h1 = NULL, *h2 = NULL;
        while(p) l = min(p->val, l), r = max(p->val, r), p = p->next;
        if(l == r) return head;
        mid = (l + r) / 2.0;
        p = head;
        while(p){
            q = p->next;
            if(p->val <= mid){
                p->next = h1;
                h1 = p;
            }else{
                p->next = h2;
                h2 = p;
            }
            p = q;
        }
        h1 = sortList(h1);
        h2 = sortList(h2);
        p = h1;
        while(p->next) p = p->next;
        p->next = h2;
        return h1;
    }
};
```

- 75.颜色分类

```c++
// 三个数据partition x占着0，y占着2，x是0的最后一位，所以下一位不是i(0)就一定是1，x下一位是i(0)时会一起向后走，是1时互换后i也可以直接向后走一位
class Solution {
public:
    void three_partition(vector<int>& nums, int l, int r, int mid){
        if(l >= r) return;
        int x = -1, y = r + 1, i = l;
        while(i < y){
            if(nums[i] == mid){
                i++;
            }else if(nums[i] < mid){
                x++;
                swap(nums[x], nums[i]);
                i++;
            }else if(nums[i] > mid){
                y--;
                swap(nums[y], nums[i]);
            }
        }
    }
    void sortColors(vector<int>& nums) {
        three_partition(nums, 0, nums.size() - 1, 1);
    }
};
```

- 面试题17.14.最小K个数

```c++
class Solution {
public:
    int getmid(int a, int b, int c){
        if(a > b) swap(a, b);
        if(a > c) swap(a, c);
        if(b > c) swap(b, c);
        return b;
    }
    void quick_select(vector<int>& arr, int l, int r,int k){
        if(l >= r) return;
        int x = l, y = r, mid = getmid(arr[l], arr[(l + r) / 2], arr[r]);
        do{
            while(arr[x] < mid) x++;
            while(arr[y] > mid) y--;
            if(x <= y){
                swap(arr[x], arr[y]);
                x++, y--;
            }
        }while(x <= y);
        if(y - l == k - 1) return; // 左区间数量等于k，直接返回
        if(y - l >= k) {
            quick_select(arr, l, y, k); // 左区间数量大于k，继续扩大
        }else{
            quick_select(arr, x, r, k - x + l); // 左区间数量小于k，找补回来
        }
        return;
    }
    vector<int> smallestK(vector<int>& arr, int k) {
		vector<int> ans;
        if(k == 0) return ans;
        quick_select(arr, 0, arr.size() - 1, k);
        while(k) ans.push_back(arr[--k]);
        return ans;
    }
};
```

- 95.不同的二叉搜索树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> dfs(int l, int r){
        vector<TreeNode*> ans;
        if(l > r){
            ans.push_back(nullptr);
            return ans;
        }
        for(int i = l; i <= r; i++){
            vector<TreeNode*> left_tree = dfs(l, i - 1);
            vector<TreeNode*> fight_tree = dfs(i + 1, r);
            for(TreeNode* left : left_tree){
                for(TreeNode* right : fight_tree){
                	TreeNode* t = new TreeNode(i, left, right);
                    ans.push_back(t);
            	}
            }
        }
        return ans;
    }
    vector<TreeNode*> generateTrees(int n) {
		if(n == 0) return vector<TreeNode*> ();
        return dfs(1, n);
    }
};
```

- 394.字符串解码

```c++
class Solution {
public:
    string decodeString(string s) {
		string ret;
        int i = 0;
        while(s[i]){
            if(s[i] < '0' || s[i] > '9'){
                ret += s[i];
                i++;
            }else{
                int num = 0;
                while(s[i] >= '0' && s[i] <= '9'){
                    num = num * 10 + (s[i++] - '0');
                }
                i++;
                int l = i, r = i, cnt = 1;
                while(cnt){
                    r += 1;
                    if(s[r] == '[') cnt++;
                    else if(s[r] == ']') cnt--;
                }
                string tmp = decodeString(s.substr(l, r - l));
                while(num--) ret += tmp;
                i = r + 1;
            }
        }
        return ret;
    }
};
```

- 11.盛最多水的容器

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
		int ans = 0, i = 0, j = height.size() - 1;
        while(i < j){
            ans = max(ans, (j - i) * min(height[i], height[j]));
            if(height[i] < height[j]) i++;
            else j--;
        }
        return ans;
    }
};
```

- 470.用 Rand7() 实现 Rand10()

```
// 没讲
```

- 239.滑动窗口最大值

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		vector<int> ans;
        if(k == 0) return ans;
        deque<int> q;
        int idx = 0;
        while(idx < nums.size()){
            if(!q.empty() && q.front() + k <= idx){
                q.pop_front();
            }
            while(!q.empty() && nums[q.back()] < nums[idx]){
                q.pop_back();
            }
            q.push_back(idx);
            idx++;
            if(idx >= k) ans.push_back(nums[q.front()]);
        }
        return ans;
    }
};
```

# 八.归并排序（Merge-Sort）：从二路到多路

## 1.归并排序的基础知识

快速排序是内部排序，归并排序是外部排序

```c++
void merge_sort(int *arr, int l, int r){
    if(l >= r) return;
    int mid = (l + r) >> 1;
    merge_sort(arr, l, mid);
    merge_sort(arr, mid + 1, mid);
    int *temp = (int *)malloc(sizeof(int) * (r - l + 1));
    int k = 0, p1 = l, p2 = mid + 1;
    while(p1 <= mid || p2 <= r){
        if((p2 > r) || (p1 <= mid && arr[p1] <= arr[p2])){
            temp[k++] = arr[p1++];
        }else{
            temp[k++] = arr[p2++];
        }
    }
    for(int i = l; i <= r; i++) arr[i] = temp[i - l];
    free(temp);
    return;
}
```

(1).归并排序在大数据场景下的应用

问题：电脑内存大小2GB，如何对一个40GB的文件进行排序？

使用多路归并排序（20路），需要在20路中选出最小值，使用小顶堆

代码展示了合并两个文件中的数据，书籍推荐：**深入理解计算机系统**

(2)归并排序的算法思想

左边处理一下，得到左边的信息

右边处理一下，得到右边的信息

最后再处理，横跨左右两边的信息

## 2.经典面试题-归并排序基础

- 剑指 Offer 51.数组中的逆序对


```c++
class Solution {
public:
    vector<int> temp;
    int countResult(vector<int>& nums, int l, int r){
        if(l >= r) return 0;
        int ans = 0, mid = (l + r) >> 1;
        ans += countResult(nums, l, mid);
        ans += countResult(nums, mid + 1, r);
        int k = l, p1 = l, p2 = mid + 1;
        while(p1 <= mid || p2 <= r){
            if((p2 > r) || (p1 <= mid && nums[p1] <= nums[p2])){
                temp[k++] = nums[p1++];
            }else{
                temp[k++] = nums[p2++];
                ans += (mid - p1 + 1);
            }
        }
        for(int i = l; i <= r; i++) nums[i] = temp[i];
        return ans;
    }
    int reversePairs(vector<int>& nums) {
        // 使得temp数组和原数组一样长
		while(temp.size() < nums.size()) temp.push_back(0);
        return countResult(nums, 0, nums.size() - 1);
    }
};
```

- 合并K个升序链表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    struct CMP{
        bool operator()(ListNode *p, ListNode *q){
            return p->val > q->val;
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
		priority_queue<ListNode *, vector<ListNode *>, CMP> q;
        for(auto x : lists){
            if(x == nullptr) continue;
            q.push(x);
        }
        ListNode ret, *p = &ret;
        while(!q.empty()){
            ListNode *cur = q.top();
            q.pop();
            p->next = cur;
            p = cur;
            if(cur->next) q.push(cur->next);
        }
        return ret.next;
    }
};
```

- 148.排序链表

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode *mergeSort(ListNode *head, int n){
        if(head == nullptr || head->next == nullptr) return head;
        int l = n / 2, r = n - l;
        ListNode *lp = head, *rp = lp, *p;
        for(int i = 1; i < l; i++, rp = rp->next);
        p = rp, rp = rp->next;
        p->next = nullptr;
        lp = mergeSort(lp, l);
        rp = mergeSort(rp, r);
        ListNode ret;
        p = &ret;
        while(lp || rp){
            if((rp == nullptr) || (lp && lp->val <= rp->val)){
                p->next = lp;
                lp = lp->next;
                p = p->next;
            }else{
                p->next = rp;
                rp = rp->next;
                p = p->next;
            }
        }
        return ret.next;
        
    }
    ListNode* sortList(ListNode* head) {
		int n = 0;
        ListNode *p = head;
        while(p) p = p->next, n += 1;
        return mergeSort(head, n);
    }
};
```

- 1305.两颗二叉搜索树中的所有元素

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void getResulet(TreeNode *root, vector<int> &arr){
        if(root == nullptr) return;
        getResulet(root->left, arr);
        arr.push_back(root->val);
        getResulet(root->right, arr);
        return;
    }
    vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
		vector<int> lnums, rnums;
        getResulet(root1, lnums);
        getResulet(root2, rnums);
        vector<int> ret;
        int p1 = 0, p2 = 0;
        while(p1 < lnums.size() || p2 < rnums.size()){
            if((p2 >= rnums.size()) || (p1 < lnums.size() && lnums[p1] <= rnums[p2])){
                ret.push_back(lnums[p1++]);
            }else{
                ret.push_back(rnums[p2++]);
            }
        }
        return ret;
    }
};
```

- 327.区间和的个数

![](.\images\372.png)

```c++
/*问题转化为
前缀和数组
lower <= sum[j] - sum[i] <upper
             j   >    i
记思考过程：在获取横跨左右两边的信息时，左右两把数据是有序的，但是右边的数据是没有和左边的数据进行排序合并的，所以右边的数据sum[j] - 左边的数据sum[i]是不会影响结果的，ex:-2、0 | 2、3的结果和0、-2 | 3、2一样，用|右边减左边都是拿到2这个数据，用排序后的数据相互减才会影响结果，因为ij互换了，说这么多希望后来的我看到能立马明白。
*/
class Solution {
public:
    int countTwoPart(vector<long long>& sum, int l1, int r1, int l2, int r2, int lower, int upper){
        int ans = 0, k1 = l1, k2 = l1;
        for(int j = l2; j <= r2; j++){
            long long a = sum[j] - upper;
            long long b = sum[j] - lower;
            while(k1 <= r1 && sum[k1] < a) k1 += 1;
            while(k2 <= r1 && sum[k2] <= b) k2 += 1;
            ans += k2 - k1;
        }
        return ans;
    }
    int mergeSort(vector<long long>& sum, int l, int r, int lower, int upper){
        if(l >= r) return 0;
        int mid = (l + r) >> 1, ans = 0;
        ans += mergeSort(sum, l, mid, lower, upper);
        ans += mergeSort(sum, mid + 1, r, lower, upper);
        ans += countTwoPart(sum, l, mid, mid + 1, r, lower, upper);
        int k = l, p1 = l, p2 = mid + 1;
        while(p1 <= mid || p2 <= r){
            if((p2 > r) || (p1 <= mid && sum[p1] <= sum[p2])){
                temp[k++] = sum[p1++];
            }else{
                temp[k++] = sum[p2++];
            }
        }
        for(int i = l; i <= r; i++) sum[i] = temp[i];
        return ans;
    }
    vector<long long> temp;
    int countRangeSum(vector<int>& nums, int lower, int upper) {
		vector<long long> sum(nums.size() + 1);
        while(temp.size() < sum.size()) temp.push_back(0);
        sum[0] = 0;
        for(int i = 0; i < nums.size(); i++) sum[i + 1] = sum[i]+ nums[i];
        return mergeSort(sum, 0, sum.size() - 1, lower, upper);
    }
};
```

- 315.计算右侧小于当前元素的个数

```c++
class Solution {
public:
    struct Data {
        Data(int val, int ind) : val(val), ind(ind), cnt(0){}
        bool operator>(const Data &a){
            return val > a.val;
        }
        int val, ind, cnt;
    };
    void mergeSort(vector<Data> &arr, int l, int r){
        if(l >= r) return;
        int mid = (l + r) >> 1;
        mergeSort(arr, l, mid);
        mergeSort(arr, mid + 1, r);
        int k = l, p1 = l ,p2 = mid + 1;
        while(p1 <= mid || p2 <= r){
            if((p2 > r) || (p1 <= mid && arr[p1] > arr[p2])){
                arr[p1].cnt += (r - p2 + 1);
                temp[k++] = arr[p1++];
            }else{
                temp[k++] = arr[p2++];
            }
        }
        for(int i = l; i <= r; i++) arr[i] = temp[i];
        return;
    }
    vector<Data> temp;
    vector<int> countSmaller(vector<int>& nums) {
		vector<Data> arr;
        for(int i = 0; i < nums.size(); i++) arr.push_back(Data{nums[i], i});
        while(temp.size() < arr.size()) temp.push_back(Data{0, 0});
        mergeSort(arr, 0, arr.size() - 1);
        vector<int> ret(nums.size());
        for(auto x : arr) ret[x.ind] = x.cnt;
        return ret;
    }
};
```

- 53.最大子序和

```c++
/*
[-2, 1,-3,4,-1,2,1,-5,4]
[-2,-1,-4,0,-1,1,2,-3,1]
[-2, 1,-2,4, 3,5,6, 1,5]
*/
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
		vector<long long> sum;
        sum.push_back(0);
        for(auto x : nums) sum.push_back(sum[sum.size() - 1] + x);
        long long ans = sum[1];
        for(long long pre = 0, i = 1; i < sum.size(); i++){
            ans = max(sum[i] - pre, ans);
            pre = min(sum[i], pre);
        }
        return ans;
    }
};
```

- 1508.子数组和排序后的区间和

```c++
/*
1, 3, 6, 10
2, 5, 9
3, 7
4
相当于多路合并
*/
class Solution {
public:
    struct Data{
        Data(int i, int j, int sum) : i(i), j(j), sum(sum){}
        int i, j, sum;
    };
    struct CMP{
        bool operator()(const Data &a, const Data &b){
            return a.sum > b.sum;
        }
    };
    int rangeSum(vector<int>& nums, int n, int left, int right) {
        priority_queue<Data, vector<Data>, CMP> q;
        for (int i = 0; i < n; i++){
            q.push(Data{i, i, nums[i]});
        }
        int ans = 0, mod = 1e9 + 7;
        for(int i = 1; i <=right; i++){
            Data d = q.top();
            q.pop();
            if(i >= left) ans = (ans + d.sum) % mod;
            if(d.j + 1 < n) q.push(Data{d.i, d.j + 1, (d.sum + nums[d.j + 1]) % mod});
        }
        return ans;
    }
};
```

- 面试题 04.08.首个共同祖先

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL) return NULL;
        if(root == p || root == q) return root;
        TreeNode *l = lowestCommonAncestor(root->left, p, q);
        TreeNode *r = lowestCommonAncestor(root->right, p, q);
        if(l != NULL && r != NULL) return root;
        if(l != NULL) return l;
        return r;
    }
};
```

- 1302.层数最深叶子节点的和

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void getResult(TreeNode* root, int k, int &max_k,int &ans){
        if(root == nullptr) return ;
        if(k == max_k) ans += root->val;
        if(k > max_k){
            max_k = k;
            ans = root->val;
        }
        getResult(root->left, k+1, max_k, ans);
        getResult(root->right, k+1, max_k, ans);
        return;
    }
    int deepestLeavesSum(TreeNode* root) {
        int max_k = 0, ans = 0;
        getResult(root, 1, max_k, ans);
        return ans;
    }
};
```

# 九.算法系列(Algorithm算法杂谈):有趣的排序思想

## 1.计数排序的基础知识

(1)计数排序的应用场景

简单的单值排序问题，排序问题中数据的值域很有限

## 2.基数排序

```c++
// 代码实现，低16位看作个位，高16位看作十位
#define low16(a) ((a) & 0xffff)
#define __high16(a) (((a) & 0xffff0000) >> 16)
// 兼容负数的写法
#define high16(a) (__high16(a) > 32767 ? (__high16(a) - 32768) : (__high16(a) + 32768))

void radix_sort(int *arr, int n){
    int cnt[65536] = {0};
    int *temp = (int *)malloc(sizeof(int) * n);
    // low 16 bit sort
    for(int i = 0; i < n; i++) cnt[low16(arr[i])] += 1; // count
    for(int i = 1; i < 65536; i++) cnt[i] += cnt[i - 1]; // prefix sum
    for(int i = n - 1; i >= 0; i--) temp[--cnt[low16(arr[i])]] = arr[i]; // placement
    // init cnt
    for(int i = 1; i < 65536; i++) cnt[i] = 0;
    // low 16 bit sort
    for(int i = 0; i < n; i++) cnt[high16(arr[i])] += 1; // count
    for(int i = 1; i < 65536; i++) cnt[i] += cnt[i - 1]; // prefix sum
    for(int i = n - 1; i >= 0; i--) arr[--cnt[high16(temp[i])]] = temp[i]; // placement
    free(temp);
    return ;
}
```

## 3.拓扑排序的基础知识

## 4.经典面试题-基础排序思想

- 1122.数组的相对排序

```c++
class Solution {
public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
        int cnt[1005] = {0};
        for(auto x : arr1) cnt[x] += 1;
        int k = 0;
        for(auto x : arr2) while(cnt[x]--) arr1[k++] = x;
        for(int i = 0; i < 1001; i++){
            if(cnt[i] <= 0) continue;
            while(cnt[i]--) arr1[k++] = i;
        }
        return arr1;
    }
};
```

- 164.最大间距

```c++
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        int cnt[65536] = {0};
        vector<int> temp(nums.size());
        for(auto x : nums) cnt[x % 65536] += 1;
        for(int i = 1; i < 65536; i++) cnt[i] += cnt[i - 1];
        for(int i = nums.size() - 1; i >= 0; i--) temp[--cnt[nums[i] % 65536]] = nums[i];
        memset(cnt, 0, sizeof(cnt));
        for(auto x : nums) cnt[x / 65536] += 1;
        for(int i = 1; i < 65536; i++) cnt[i] += cnt[i - 1];
        for(int i = nums.size() - 1; i >= 0; i--) nums[--cnt[temp[i] / 65536]] = temp[i];
        int ans = 0;
        for(int i = 1; i < nums.size(); i++){
            ans = max(ans, nums[i] - nums[i - 1]);
        }
        return ans;
    }
};
```

- 274. H指数

```c++
/*
[3,0,6,1,5]
[0,1,3,5,6]
  4x 3 2 1  <-h
*/
class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.begin(), citations.end());
        int h = 1, n = citations.size();
        while(h <= n && citations[n - h] >= h) ++h;
        return h - 1;
    }
};
```

- 207.课程表

```c++
// 拓扑排序
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        int indeg[numCourses];
        memset(indeg, 0, sizeof(indeg));
        vector<vector<int>> g(numCourses);
        queue<int> q;
        for(auto x : prerequisites){
            indeg[x[0]] += 1;
            g[x[1]].push_back(x[0]);
        }
        for(int i = 0; i < numCourses; i++){
            if(indeg[i] == 0) q.push(i);
        }
        int cnt = 0;
        while(!q.empty()){
            int ind = q.front();
            q.pop(); cnt += 1;
            cout << "pop : " << ind << endl;
            for(auto to : g[ind]){
               indeg[to] -= 1;
               if(indeg[to] == 0) q.push(to);
            }
        }
        return cnt == numCourses;
    }
};
```

- 210.课程表Ⅱ

```c++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        int indeg[numCourses];
        memset(indeg, 0, sizeof(indeg));
        vector<vector<int>> g(numCourses);
        queue<int> q;
        for(auto x : prerequisites){
            indeg[x[0]] += 1;
            g[x[1]].push_back(x[0]);
        }
        for(int i = 0; i < numCourses; i++){
            if(indeg[i] == 0) q.push(i);
        }
        vector<int> ans;
        while(!q.empty()){
            int ind = q.front();
            q.pop(); ans.push_back(ind);
            cout << "pop : " << ind << endl;
            for(auto to : g[ind]){
               indeg[to] -= 1;
               if(indeg[to] == 0) q.push(to);
            }
        }
        if(ans.size() == numCourses) return ans;
        return vector<int>();
    }
};
```

- 56.合并区间

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> arr;
        vector<int> temp(2);
        for(auto x : intervals){
            temp[0] = x[0];
            temp[1] = 1;
            arr.push_back(temp);
            temp[0] = x[1];
            temp[1] = -1;
            arr.push_back(temp);
        }
        sort(arr.begin(), arr.end(),
            [](const vector<int> &a, const vector<int> &b) -> bool{
                // 先按节点大小排序，大小一样先加再减
                if(a[0] - b[0]) return a[0] < b[0];
                return a[1] > b[1];
            }
        );
        int pre = -1, sum = 0;
        vector<vector<int>> ret;
        for(int i = 0; i < arr.size(); i++){
            if(pre == -1) pre = arr[i][0];
            sum += arr[i][1];
            if(sum == 0){
                temp[0] = pre;
                temp[1] = arr[i][0];
                ret.push_back(temp);
                pre = -1;
            } 
        }
        return ret;
    }
};
```

- 1288.删除被覆盖区间

```c++
class Solution {
public:
    int removeCoveredIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(),
            [](const vector<int> &a, const vector<int> &b) -> bool{
                if(a[0] - b[0]) return a[0] < b[0];
                return a[1] > b[1];
            }
        );
        int cnt = 0, pre = -1;
        for(auto x : intervals){
            if(pre >= x[1]) cnt += 1;
            else pre = x[1];
        }
        return intervals.size() - cnt;
    }
};
```

- 491.递增子序列

```c++
// buff代表在k之前已经选择了多少元素
class Solution {
public:
    void getResult(vector<int>& nums,int k, vector<int> buff, vector<vector<int>> &ret){
        if(buff.size() > 1) ret.push_back(buff);
        // 肯定得push一个数，先push一个0。
        buff.push_back(0);
        unordered_map<int, int> can;
        for(int i = k; i < nums.size(); i++){
            // 用map判断一个数字是否出现过。ex:4 6 7 7,中的7出现了两次，4只需要和其中一个7匹配即可
            if(can.find(nums[i]) != can.end()) continue;
            if(buff.size() == 1 || nums[i] >= buff[buff.size() - 2]){
                buff[buff.size() - 1] = nums[i];
                can[nums[i]] = 1;
                getResult(nums, i + 1, buff, ret);
            }
        }
        return;
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        vector<vector<int>> ret;
        getResult(nums, 0, vector<int>(), ret);
        return ret;
    }
};
```

- 面试题 04.12. 求和路径

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int getpathSum(TreeNode* root, int sum){
        if(root == NULL) return 0;
        int val = sum - root->val;
        return (root->val == sum) + getpathSum(root->left, val) + getpathSum(root->right, val);
    }
    int pathSum(TreeNode* root, int sum) {
        if(root == NULL) return 0;
        int a = getpathSum(root, sum);
        // 分选择root节点和不选择root节点两种情况，不选择root节点又分为左树和右树两种情况
        return a + pathSum(root->left, sum) + pathSum(root->right, sum);
    }
};
```

# 十.二分算法（Binary-Search）

## 1.二分查找的基础知识

二分的是待查找区间

核心思想：二分查找在进行区间调整的时候，都要保证，答案在查找区间范围内

```c++
int binary_search(int *arr, int n, int x){
    int head = 0, tail = n- 1, mid;
    while(head <= tail){
        mid = head + ((tail - head) >> 1);
        if(arr[mid] == x) return mid;
        if(arr[mid] < x) head = mid + 1;
        else tail = mid - 1;
    }
    return -1;
}
```

## 2.二分查找——泛型情况

0 0 0 0 1 1 1 1 1 1

01模型：查找第一个1

1 1 1 1 1 0 0 0 0 0

10模型：查找第最后一个1，可以找到第一个0再向前找一位

0可以代表条件不成立，1代表条件成立

求第一个大于x的值

```c++
int binary_search_01(int *arr, int n, int x){
    int head = 0, tail = n - 1, mid;
    while(head < tail){
        mid = head + ((tail - head) >> 1);
        if(arr[mid] < x) head = mid + 1;// 0
        else tail = mid;// 为1时不可跳过mid
    }
    return head;
}
// 大范围二分，小范围顺序，可以避免边界情况
int binary_search_01(int *arr, int n, int x){
    int head = 0, tail = n - 1, mid;
    while(tail - head > 3){
        mid = head + ((tail - head) >> 1);
        if(arr[mid] < x) head = mid + 1;
        else tail = mid;// 为1时不可跳过mid
    }
    for(int i = head; i <= tail; i++){
        if(arr[i] >= x) return i;
    }
    return head;
}
```

## 3.二分中的数组和函数

数组：f[x] -> y 映射

函数：f(x) -> y 映射

单调数组：下标 <=> 值

单调函数：参数 <=> 值（扩展：二分求单调函数参数）

任何可以应用于数组的算法都可以应用于某种性质的函数上

![](.\images\二分函数.jpg)

## 4.经典面试题-简单二分应用

- 69.x的平方根(10模型)

```c++
/*
x = 10求y^2 <= 10
0 1 2 3 4  5
0 1 4 9 16 25
1 1 1 1 0  0
求最后一个1
*/ 
class Solution {
public:
    int mySqrt(int x) {
		double head = 0, tail = x, mid;
        // 要是x是1，不加1，得到的结果就是0了
        tail += 1;
        for(int i = 0; i < 100; i++){
            mid = head + ((tail - head) / 2.0);
            if(mid * mid <= x) head = mid;
            else tail = mid;
        }
        return floor(head);
    }
};
class Solution {
public:
    int mySqrt(int x) {
		int head = 0, tail = x, mid;
        while(head < tail){
            mid = head + ((tail - head) / 2) + 1;
            if(mid <= x / mid) head = mid;// 1
            else tail = mid - 1;
        }
        return head;
    }
};

```

- 35.搜索插入位置

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
		int head = 0, tail = nums.size() - 1,mid;
        while(tail - head > 3){
            mid = (head + tail) >> 1;
            if(nums[mid] >= target) tail = mid;
            else head = mid + 1;
        }
        for(int i = head; i <= tail; i++){
            if(nums[i] >= target) return i;
        }
        return nums.size();
    }
};
```

- 1.两数之和

```c++
// 不对原数组排序，创造下标数组进行排序，在下标数组上做二分
class Solution {
public:
    int binary_search(vector<int> &nums, vector<int> &ind, int head, int x){
        int tail = ind.size() - 1, mid;
        while(head <= tail){
            mid = (head + tail) >> 1;
            if(nums[ind[mid]] == x) return mid;
            if(nums[ind[mid]] < x) head = mid + 1;
            else tail = mid - 1;
        }
        return -1;
    }
    vector<int> twoSum(vector<int>& nums, int target) {
		vector<int> ind(nums.size());
        for(int i = 0; i < ind.size(); i++) ind[i] = i;
        sort(ind.begin(), ind.end(), [&](int i, int j) {return nums[i] < nums[j];});
		vector<int> ret(2);
        for(int i = 0; i < ind.size(); i++){
			int val = nums[ind[i]];
            int j = binary_search(nums, ind, i + 1, target - val);
            if(j == -1) continue;
            ret[0] = ind[i];
            ret[1] = ind[j];
            if(ret[0] > ret[1]) swap(ret[0], ret[1]);
        }
        return ret;
    }
};
```

- 34.在排序数组中查找元素的第一个和最后一个位置

```c++
class Solution {
public:
    int binary_search_01(vector<int> &nums, int x){
        int head = 0, tail = nums.size() - 1,mid;
        while(tail - head > 3){
            mid = (head + tail) >> 1;
            if(nums[mid] >= x) tail = mid;
            else head = mid + 1;
        }
        for(int i = head; i <= tail; i++){
            if(nums[i] >= x) return i;
        }
        return nums.size();
    }
    vector<int> searchRange(vector<int>& nums, int target) {
		vector<int> ret(2);
        ret[0] = binary_search_01(nums, target);
        if(ret[0] == nums.size() || nums[ret[0]] != target){
            ret[0] = ret[1] = -1;
            return ret;
        }
        ret[1] = binary_search_01(nums, target + 1) - 1;
        return ret;
    }
};
```

- 1658.将 x 减到 0 的最小操作数

```c++
// 使用两个前缀和数组，一个从左向右、一个从右向左，因为元素都是正整数，所以都是单调函数，遍历左边数组的每个值，在右边数组中找相加等于x的值
class Solution {
public:
    int binary_search(vector<int>& nums, int x){
        int head = 0, tail = nums.size()- 1, mid;
        while(head <= tail){
            mid = head + ((tail - head) >> 1);
            if(nums[mid] == x) return mid;
            if(nums[mid] < x) head = mid + 1;
            else tail = mid - 1;
        }
        return -1;
    }
    int minOperations(vector<int>& nums, int x) {
        vector<int> suml(nums.size() + 1);
		vector<int> sumr(nums.size() + 1);
        suml[0] = sumr[0] = 0;
        for(int i = 0; i < nums.size(); i++) suml[i + 1] = suml[i] + nums[i];
        for(int i = nums.size() - 1; i >= 0; i--) sumr[nums.size() - i] = sumr[nums.size() - i - 1] + nums[i];
        int ans = -1;
        for(int i = 0; i < suml.size(); i++){
            int j = binary_search(sumr, x - suml[i]);
            if(j == -1 || i + j > nums.size()) continue;
            if(ans == -1 || ans > i + j) ans = i + j;
        }
        return ans;
    }
};
```

- 475.供暖器

```c++
class Solution {
public:
    int binary_search_01(vector<int> &nums, int x){
        int head = 0, tail = nums.size() - 1, mid;
        while(head < tail){
            mid = (head + tail) >> 1;
            if(nums[mid] >= x) tail = mid;
            else head = mid + 1;
        }
        return head;
    }
    int findRadius(vector<int>& houses, vector<int>& heaters) {
		sort(heaters.begin(), heaters.end());
        int ans = 0;
        for(auto x : houses){
            int j = binary_search_01(heaters, x);
            int a = abs(heaters[j] - x);
            int b = j ? x - heaters[j - 1] : a + 1;
            ans = max(ans, min(a, b));
        }
        return ans;
    }
};
```

- 81.搜索旋转排序数组 II

```c++
// 试了不需要head和tail变量也是可以的，我觉得不需要
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        if(nums[0] == target || nums[nums.size() - 1] == target) return true;
        int l = 0, r = nums.size() - 1, mid, head, tail;
        while(l < nums.size() && nums[l] == nums[0]) l++;
        while(r >= 0 && nums[r] == nums[0]) r--;
        head = l, tail = r;
        while(l <= r){
            mid = (l + r) >> 1;
            if(nums[mid] == target) return true;
            if(nums[mid] <= nums[tail]){
                if(target <= nums[tail] && target > nums[mid]) l = mid + 1;
                else r = mid - 1;
            }else{
                if(target < nums[mid] && target >= nums[head]) r = mid - 1;
                else l = mid + 1;
            }
        }
        return false;
    }
};
```

- 4.寻找两个正序数组的中位数

```c++
// 二分的是问题的规模,代码有问题，但是找不出来
class Solution {
public:
    double findK(vector<int> &nums1, vector<int> &nums2, int i, int j, int k){
        if(i == nums1.size()) return nums2[j + k - 1];
        if(j == nums2.size()) return nums1[i + k - 1];
        if(k == 1) return (nums1[i] < nums2[j] ? nums1[i] : nums2[j]);
        int a = min(k / 2, (int)nums1.size() - i);
        int b = min(k - a, (int)nums2.size() - j);
        a = k - b;
        if(nums1[i + a - 1] <= nums2[i + b - 1]){
            return findK(nums1, nums2, i + a, j, k - a);
        }
        return findK(nums1, nums2, i, j + b, k - b);
    }
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size(), mid = (n + m + 1) / 2;
        double a = findK(nums1, nums2, 0, 0, mid);
        if((n + m) % 2 == 1) return a;
        double b = findK(nums1, nums2, 0, 0, mid + 1);
        return (a + b) / 2.0;
    }
};
```

# 十一.哈希表与布隆过滤器

## 1.哈希表的基础知识

​		哈希表是用来解决快速索引数据的问题。哈希表，其实想利用到数组快速存取数据的这个特性。要是想利用这个特性，就需要完成最关键的一部分。就是将任意数据映射转换成数组下标，既哈希函数完成的事情。

## 2.哈希冲突处理方法

1. 开放定址法
2. 再哈希法
3. 建立公共溢出区
4. 链式地址法（拉链法）

```c++
/*
1
装填因子 = 存储元素个数/哈希总容量
一般情况下装填因子大于0.75就该考虑扩容了
*/
class HashTable{
public:
    HashTable(int n = 100) : flag(n), data(n), cnt(0){}
    void insert(string s){
        int ind = hash_func(s) % data.size(); // 计算哈希值
        recalc_ind(ind, s); // 冲突处理
        if(flag[ind] == false){
        	data[ind] = s;
        	flag[ind] = true;
            cnt += 1;
            if(cnt * 100 > data.size() * 75){
                expand();
            }
        }
        return ;
    }
    bool find(string s){
        int ind = hash_func(s) % data.size(); // 计算哈希值
        recalc_ind(ind, s); // 冲突处理
        return flag[ind];
    }
private:
    int cnt;
    vector<string> data;
    vector<bool> flag;
    // 均摊时间复杂度
    void expand(){
        int n = data.size() * 2;
        HashTable h(n);
        for(int i = 0; i < data.size(); i++){
            if(flag[i] == false) continue;
            h.insert(data[i]);
        }
        *this = h;
        return;
    }
    // BKDRHash
    int hash_func(string &s){
        int seed = 131, hash = 0;
        for(int i = 0; s[i]; i++){
            hash = hash * seed + s[i];
        }
        return hash & 0x7fffffff;
    }
    // 开放定址法，平方探测法
    void recalc_ind(int &ind, string &s){
        int t = 1;
        while(flag[ind] && data[ind] != s){
            ind += t * t;
            t += 1;
            ind %= data.size();
        }
        return;
    }
}
```

```c++
// 3
class HashTable{
public:
    HashTable(int n = 100) : flag(n), data(n), cnt(0){}
    void insert(string s){
        int ind = hash_func(s) % data.size(); // 计算哈希值
        recalc_ind(ind, s); // 冲突处理
        if(flag[ind] == false){
        	data[ind] = s;
        	flag[ind] = true;
            cnt += 1;
            if(cnt * 100 > data.size() * 75){
                expand();
            }
        }else if(data[ind] != s){
            buff.insert(s);
        }
        return ;
    }
    bool find(string s){
        int ind = hash_func(s) % data.size(); // 计算哈希值
        recalc_ind(ind, s); // 冲突处理
        if(flag[ind] == false) return false;
        if(data[ind] == s) return true;
        return buff.find(s) != buff.end();
    }
private:
    int cnt;
    vector<string> data;
    vector<bool> flag;
    // set底层是红黑树，查找效率logn
    set<string> buff;

    void expand(){
        int n = data.size() * 2;
        HashTable h(n);
        for(int i = 0; i < data.size(); i++){
            if(flag[i] == false) continue;
            h.insert(data[i]);
        }
        for(auto x : buff){
            h.insert(x);
        }
        *this = h;
        return;
    }
    // BKDRHash
    int hash_func(string &s){
        int seed = 131, hash = 0;
        for(int i = 0; s[i]; i++){
            hash = hash * seed + s[i];
        }
        return hash & 0x7fffffff;
    }
    void recalc_ind(int &ind, string &s){
        return;
    }
}
```

```c++
// 4
class Node{
public:
    Node(string data = "",Node *next = nullptr) : data(), next(nullptr){}
    string data;
    Node *next;
    void insert(Node *node){
        node.next = this.next;
        this.next = node;
        return;
    }
}
class HashTable{
public:
    HashTable(int n = 100) : data(n), cnt(0){}
    void insert(string s){
        int ind = hash_func(s) % data.size(); // 计算哈希值
        recalc_ind(ind, s); // 冲突处理
		Node *p = &data[ind];
        while(p->next && p->next->data != s) p = p->next;
        if(p->next == nullptr){
            p->insert(new Node(s));
            cnt += 1; 
            if(cnt > data.size() * 3) expand();
        }
        return ;
    }
    bool find(string s){
        int ind = hash_func(s) % data.size(); // 计算哈希值
        recalc_ind(ind, s); // 冲突处理
        Node *p = data[ind];
        while(p && p->data != s) p = p->next;
        return p != nullptr;
    }
private:
    int cnt;
    vector<Node> data;

    void expand(){
        int n = data.size() * 2;
        HashTable h(n);
        for(int i = 0; i < data.size(); i++){
        	Node *p = data[i].next;
            while(p){
                h.insert(p->data);
                p = p->next;
            }  
        }
        *this = h;
        return;
    }
    // BKDRHash
    int hash_func(string &s){
        int seed = 131, hash = 0;
        for(int i = 0; s[i]; i++){
            hash = hash * seed + s[i];
        }
        return hash & 0x7fffffff;
    }
    void recalc_ind(int &ind, string &s){
        return;
    }
}
```

## 3.布隆过滤器

传统哈希表，存储空间与元素数量有关

布隆过滤器，存储空间与元素数量无关

有两部分构成

①一片数据存储区，存储二进制标记

②一组哈希函数，数据映射成不同的数组下标，将下标分别标记为1

查找时对应下标都是1，那么数据大概率存在，存在误判率

应用场景：

①大数据（url判重）

②信息安全有要求

## 4.面试题

- 705.设计哈希集合

```c++
class Node{
public:
    Node(int key = 0, Node *next = nullptr) : key(key), next(next){}
    int key;
    Node *next;
    void insert_after(Node *node){
        node->next = this->next;
        this->next = node;
        return;
    }
    void remove_after(){
        if(this->next  == nullptr) return;
        Node *p = this->next;
        this->next = this->next->next;
        delete p;
        return;
    }
};
class MyHashSet {
public:
    vector<Node> data;
    MyHashSet() : data(100) {}
    
    int hash_func(int key){return key & 0x7fffffff;}

    void add(int key) {
        if(contains(key)) return;
        int ind = hash_func(key) % data.size();
        data[ind].insert_after(new Node(key));
        return;
    }
    
    void remove(int key) {
        int ind = hash_func(key) % data.size();
        Node *p = &data[ind];
        while(p->next && p->next->key != key) p = p->next;
        p->remove_after();
        return;
    }
    
    bool contains(int key) {
        int ind = hash_func(key) % data.size();
        Node *p = data[ind].next;
        while(p && p->key != key) p = p->next;
        return p != nullptr;
    }
};

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet* obj = new MyHashSet();
 * obj->add(key);
 * obj->remove(key);
 * bool param_3 = obj->contains(key);
 */
```

- 706.设计哈希映射

```c++
class Node{
public:
    Node(int key = 0, int value = 0, Node *next = nullptr) : key(key), value(value), next(next){}
    int key, value;
    Node *next;
    void insert_after(Node *node){
        node->next = this->next;
        this->next = node;
        return;
    }
    void remove_after(){
        if(this->next  == nullptr) return;
        Node *p = this->next;
        this->next = this->next->next;
        delete p;
        return;
    }
};
class MyHashSet {
public:
    vector<Node> data;
    MyHashSet() : data(100) {}
    
    int hash_func(int key){return key & 0x7fffffff;}

    void add(int key) {
        if(contains(key)) return;
        int ind = hash_func(key) % data.size();
        data[ind].insert_after(new Node(key));
        return;
    }
    
    void remove(int key) {
        int ind = hash_func(key) % data.size();
        Node *p = &data[ind];
        while(p->next && p->next->key != key) p = p->next;
        p->remove_after();
        return;
    }
    
    bool contains(int key) {
        int ind = hash_func(key) % data.size();
        Node *p = data[ind].next;
        while(p && p->key != key) p = p->next;
        return p != nullptr;
    }
};

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet* obj = new MyHashSet();
 * obj->add(key);
 * obj->remove(key);
 * bool param_3 = obj->contains(key);
 */
```

- 面试题 16.25. LRU 缓存

```c++
class Node{
public:
    Node(int key = 0, int value = 0, Node *prev = nullptr, Node *next = nullptr) : key(key), value(value), prev(prev), next(next){}
    int key, value;
    Node *next, *prev;
    void insert_prev(Node *node){
        node->next = this;
        node->prev = this->prev;
        if(this->prev) this->prev->next = node;
        this->prev = node;
        return;
    }
    Node *remove_this(){
        if(this->prev) this->prev->next = this->next;
        if(this->next) this->next->prev = this->prev;
        this->next = this->prev = nullptr;
        return this;
    }
};
class HashList{
public:
    int capacity;
    Node head, tail;
    unordered_map<int, Node *>data;
    HashList(int capacity) : capacity(capacity) {
        head.next = &tail;
        tail.prev = &head;
    }
    void put(int key, int value){
        if(data.find(key) != data.end()){
            data[key]->value = value;
            data[key]->remove_this();
        }else{
            data[key] = new Node(key, value);
        }
        tail.insert_prev(data[key]);
        if(data.size() > capacity){
            data.erase(data.find(head.next->key));
            delete head.next->remove_this();
        }
        return;
    }
    int get(int key){
        if(data.find(key) == data.end()) return -1;
        data[key]->remove_this();
        tail.insert_prev(data[key]);
        return data[key]->value;
    }
};
class LRUCache {
public:
    HashList h;
    LRUCache(int capacity) : h(capacity) {}
    
    int get(int key) {
		return h.get(key);
    }
    
    void put(int key, int value) {
		h.put(key, value);
        return;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

- 535.TinyURL 的加密与解密

```c++
class Solution {
public:
    Solution() { srand(time(0)); }
    char ch(int x){
        x %= 62;
        if(x < 26) return x + 'a';
        if(x < 52) return x - 26 + 'A';
        return x - 52 + '0';
    }
    string rand_string(int n){
        string s = "";
        for(int i = 0; i < n; i++){
            s += ch(rand());
        }
        return s;
    }
    unordered_map<string, string> h;
    // Encodes a URL to a shortened URL.
    string encode(string longUrl) {
        string s;
        do{
            s = rand_string(5);
        }while(h.find(s) != h.end());
        h[s] = longUrl;
        return s;
    }

    // Decodes a shortened URL to its original URL.
    string decode(string shortUrl) {
        return h[shortUrl];
    }
};

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));

// Your Solution object will be instantiated and called as such:
// Solution solution;
// solution.decode(solution.encode(url));
```

- 187.重复的DNA序列

```c++
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        unordered_map<string, int> h;
        for(int i = 0, j = s.size() - 9; i < j; i++){
            h[s.substr(i, 10)] += 1;
        }
        vector<string> ret;
        for(auto x : h){
            if(x.second == 1) continue;
            ret.push_back(x.first);
        }
        return ret;
    }
};
```

- 318.最大单词长度乘积

```c++
// 学习|=
class Solution {
public:
    int maxProduct(vector<string>& words) {
        vector<int> mark(words.size());
        for(int i = 0; i < words.size(); i++){
            for(auto c : words[i]){
                mark[i] |= (1 << (c - 'a'));
            }
        }
        int ans = 0;
        for(int i = 0; i < words.size(); i++){
            for(int j = i + 1; j < words.size(); j++){
                if(mark[i] & mark[j]) continue;
                ans = max(ans, int(words[i].size() * words[j].size()));
            }
        }
        return ans;
    }
};
```

- 240.搜索二维矩阵 II

```c++
// 左上角和右下角特殊，最多走m + n步可以找到
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int i = 0, j = matrix[0].size() - 1;
        while(i < matrix.size() && j >= 0){
            if(matrix[i][j] == target) return true;
            if(matrix[i][j] < target) i += 1;
            else j -= 1;
        }
        return false;
    }
};
```

- 979.在二叉树中分配硬币

```c++
// 最优既每条边都是单向流动
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // n节点数量、m硬币数量
    int getResult(TreeNode* root, int &n, int &m){
        n = m = 0;
        if(root == nullptr) return 0;
        n = 1; m = root->val;
        int ans = 0, n1, m1;
        ans += getResult(root->left, n1, m1);// 左节点下的次数
        ans += abs(n1 - m1);// 根到左节点那条边的次数
        n += n1, m += m1;// 累加左节点下的节点数量和硬币数量
        ans += getResult(root->right, n1, m1);// 右节点同理
        ans += abs(n1 - m1);
        n += n1, m += m1;
        return ans;
    }
    int distributeCoins(TreeNode* root) {
        int n, m;
        return getResult(root, n, m);
    }
};
```

- 430.扁平化多级双向链表

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* prev;
    Node* next;
    Node* child;
};
*/

class Solution {
public:
    Node* flatten(Node* head) {
        Node *p = head, *q, *k;
        while(p){
            if(p->child){
                q = p->next;
                k = flatten(p->child);
                p->child = nullptr;// 扁平化子节点后，置为nullptr
                p->next = k;
                k->prev = p;
                while(p->next) p = p->next;
                p->next = q;
                if(q) q->prev = p;
            }
            p = p->next;
        }
        return head;
    }
};
```

- 863.二叉树中所有距离为 K 的结点

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void dfs(TreeNode* root, int c, int k, vector<int> &ret){
        if(k < 0) return;
        if(root == nullptr) return;
        if(c == k){
            ret.push_back(root->val);
            return;
        }
        dfs(root->left, c + 1, k, ret);
        dfs(root->right, c + 1, k, ret);
        return;
    }
    TreeNode *getResult(TreeNode* root, TreeNode* target, int &k, vector<int> &ret){
        if(root == nullptr) return nullptr;
        if(root == target){
            dfs(root, 0, k, ret);
            return root;
        }
        if(getResult(root->left, target, k, ret)){
            k -= 1;
            if(k == 0) ret.push_back(root->val);
            dfs(root->right, 0, k - 1, ret);
            return target;
        }else if(getResult(root->right, target, k, ret)){
            k -= 1;
            if(k == 0) ret.push_back(root->val);
            dfs(root->left, 0, k - 1, ret);
            return target;
        }
        return nullptr;
    }
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        vector<int> ret;
        getResult(root, target, k, ret);
        return ret;
    }
};
```

# 十二.深搜（DFS）与广搜（BFS）：初识问题状态空间

## 1.搜索的核心概念

问题求解树，是思维逻辑的结构，关键点是定义树的状态节点

1.什么是深搜和广搜

对于问题求解树的不同的遍历方式

2.什么是搜索剪枝和优化？

排除某些问题求解树中的子树的遍历过程

3.设计搜索算法的核心关键点是什么？

设计状态

## 2.DFS-深度优先搜索

是以递归的程序形态为外在表现

## 3.BFS-广度优先搜索

借助队列进行层序遍历

一步一步的求解，适合最优化问题的求解

## 4.经典面试题-广搜系列题目

- 993.二叉树的堂兄弟节点

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
// 深搜
class Solution {
public:
    int dfs(TreeNode* root, int x, TreeNode *&father){
        if(root == nullptr) return -1;
        if(root->val == x) return 0;
        int l;
        father = root;
        l = dfs(root->left, x, father);
        if(l != -1) return l + 1;
        father = root;
        l = dfs(root->right, x, father);
        if(l != -1) return l + 1;
        return -1;
    }
    bool isCousins(TreeNode* root, int x, int y) {
        int d1, d2;
        TreeNode *father_x = nullptr, *father_y = nullptr;
        d1 = dfs(root, x, father_x);
        d2 = dfs(root, y, father_y);
        return d1 == d2 && father_x != father_y;
    }
};
```

对于广搜算法，状态一般情况下表现为一类打包的数据结构

```c++
// 广搜
class Solution {
public:
    struct Data{
        Data(TreeNode *node = nullptr, TreeNode *father = nullptr, int deepth = 0)
        : node(node), father(father), deepth(deepth) {}
        TreeNode *node, *father;
        int deepth;
    };
    bool isCousins(TreeNode* root, int x, int y) {
        int d1, d2;
        TreeNode *father_x = nullptr, *father_y = nullptr;
        queue<Data> q;
        q.push(Data(root, nullptr, 0));
        while(!q.empty()){
            Data cur = q.front();
            if(cur.node->val == x) d1 = cur.deepth, father_x = cur.father;
            if(cur.node->val == y) d2 = cur.deepth, father_y = cur.father;
            if(cur.node->left){
                q.push(Data(cur.node->left, cur.node, cur.deepth + 1));
            }
            if(cur.node->right){
                q.push(Data(cur.node->right, cur.node, cur.deepth + 1));
            }
            q.pop();
        }
        return d1 == d2 && father_x != father_y;
    }
};
```

- 542.01 矩阵

```c++
// 先把0放入队列，然后从0处走一步能到达的就是1，1再走一步处就是2
class Solution {
public:
    struct Data{
        Data(int i = 0, int j = 0, int k = 0) : i(i), j(j), k(k) {}
        int i, j, k;
    };
    void init_queue(
        queue<Data> &q, vector<vector<int>> &vis,
        int n, int m, vector<vector<int>> &mat
    ){
        for(int i = 0; i < n; i++){
            vis.push_back(vector<int>());
            for(int j = 0; j < m; j++){
                vis[i].push_back(-1);
            }
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(mat[i][j]) continue;
                vis[i][j] = 0;
                q.push(Data(i, j, 0));
            }
        }
        return;
    }
    // 方向数组，走一步到达的下标
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        queue<Data> q;
        vector<vector<int>> vis;
        init_queue(q, vis, n, m, mat);
        while(!q.empty()){
            Data cur = q.front();
            for(int k = 0; k < 4; k++){
                int x = cur.i + dir[k][0];
                int y = cur.j + dir[k][1];
                if(x < 0 || x >= n) continue;
                if(y < 0 || y >= m) continue;
                if(vis[x][y] != -1) continue;
                vis[x][y] = cur.k + 1;
                q.push(Data(x, y, cur.k + 1));
            }
            q.pop();
        }
        return vis;
    }
};
```

- 1091.二进制矩阵中的最短路径

```c++
class Solution {
public:
    struct Data{
        Data(int i = 0, int j = 0, int l = 0) : i(i), j(j), l(l) {}
        int i, j, l;
    };
    // 方向数组，走一步到达的下标
    int dir[8][2] = {
        0, 1, 1, 0, 0, -1, -1, 0,
        1, -1, -1, 1, 1, 1, -1, -1
    };
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<int>> vis;
        for(int i = 0; i < n; i++){
            vis.push_back(vector<int>(n));
        }
        queue<Data> q;
        if(grid[0][0]) return -1;
        vis[0][0] = 1;
        q.push(Data(0, 0, 1));
        while(!q.empty()){
            Data cur = q.front();
            if(cur.i == n - 1 && cur.j == n - 1) return cur.l;
            for(int k = 0; k < 8; k++){
                int x = cur.i + dir[k][0];
                int y = cur.j + dir[k][1];
                // continue 就是排除非法条件
                if(x < 0 || x >= n) continue;
                if(y < 0 || y >= n) continue;
                if(grid[x][y]) continue;
                if(vis[x][y]) continue;
                vis[x][y] = 1;
                q.push(Data(x, y, cur.l + 1));
            }
            q.pop();
        }
        return -1;
    }
};
```

- 752. 打开转盘锁

```c++
class Solution {
public:
    struct Data{
        Data(string s = "", int l = 0) : s(s), l(l) {}
        string s;
        int l;
    };
    string getS(string &s, int i, int k){
        string ret = s;
        switch(k){
            case 0: ret[i] += 1; break;
            case 1: ret[i] -= 1; break;
        }
        if(ret[i] < '0') ret[i] = '9';
        if(ret[i] > '9') ret[i] = '0';
        return ret;
    }
    int openLock(vector<string>& deadends, string target) {
        queue<Data> q;
        unordered_set<string> h;
        for(auto x : deadends) h.insert(x);
        if(h.find("0000") != h.end()) return -1;
        h.insert("0000");
        q.push(Data("0000", 0));
        while(!q.empty()){
            Data cur = q.front();
            if(cur.s == target) return cur.l;
            for(int i = 0; i < 4; i++){
                for(int k = 0; k < 2; k++){
                    string t = getS(cur.s, i, k);
                    if(h.find(t) != h.end()) continue;
                    h.insert(t);
                    q.push(Data(t, cur.l + 1));
                }  
            }
            q.pop();
        }
        return -1;
    }
};
```

- 剑指 Offer 13. 机器人的运动范围

```c++
class Solution {
public:
    // 技巧：把二维坐标转化为整数，行号 * 列数 + 列号，ex:3行4列，坐标(1,2) => 1 * 4 + 2 = 6
    struct Data{
        Data(int i = 0, int j = 0) : i(i), j(j) {}
        int i, j;
    };
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    int movingCount(int m, int n, int k) {
        vector<int> dsum(100);
        for(int i = 0; i < 10; i++){
            for(int j = 0; j < 10; j++){
                dsum[i * 10 + j] = i + j;
            }
        }
        queue<Data> q;
        unordered_set<int> h;
        h.insert(0);
        q.push(Data(0 ,0));
        int ans = 0;
        while(!q.empty()){
            Data cur = q.front();
            ans += 1;
            for(int i = 0; i < 4; i++){
                int x = cur.i + dir[i][0];
                int y = cur.j + dir[i][1];
                if(x < 0 || x >= m) continue;
                if(y < 0 || y >= n) continue;
                if(h.find(x * n + y) != h.end()) continue;
                if(dsum[x] + dsum[y] > k) continue;
                h.insert(x * n + y);
                q.push(Data(x, y));
            }
            q.pop();
        }
        return ans;
    }
};
```

- 130. 被围绕的区域

```c++
class Solution {
public:
    // 深搜会把状态设计成参数
    int n, m;
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    void dfs(int i, int j, vector<vector<char>>& board){
        board[i][j] = 'o';
        // 遍历问题求解树的每条边
        for(int k = 0; k < 4; k++){
            int x = i + dir[k][0];
            int y = j + dir[k][1];
            if(x < 0 || x >= n) continue;
            if(y < 0 || y >= m) continue;
            if(board[x][y] != 'O') continue;
            dfs(x, y,board);
        }
    }
    void solve(vector<vector<char>>& board) {
        n = board.size(), m = board[0].size();
        for(int i = 0; i < n; i++){
            if(board[i][0] == 'O') dfs(i, 0, board);
            if(board[i][m - 1] == 'O') dfs(i, m - 1, board);
        }
        for(int j = 0; j < m; j++){
            if(board[0][j] == 'O') dfs(0, j, board);
            if(board[n - 1][j] == 'O') dfs(n - 1, j, board);
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(board[i][j] == 'O') board[i][j] = 'X';
                else if(board[i][j] == 'o') board[i][j] = 'O';
            }
        }
        return;
    }
};
```

- 494. 目标和

```c++
// 耗时太长，需要优化
class Solution {
public:
    int dfs(int i, int target, vector<int>& nums){
        if(i == nums.size()){
            return target == 0;
        }
        int ans = 0;
        ans += dfs(i + 1, target - nums[i], nums);
        ans += dfs(i + 1, target + nums[i], nums);
        return ans;
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        return dfs(0, target, nums);
    }
};
```

```c++
// 记忆化优化，不是搜索算法专属，本质上：
// 二分中讲过数组和函数本质上是一样的，数组就是展开的函数，函数就是压缩的数组
class Solution {
public:
    typedef pair<int, int> PII;
    struct CMP{
        int operator()(const PII &a) const {
            return a.first ^ a.second;
        }
    };
    unordered_map<PII, int, CMP> h;
    int dfs(int i, int target, vector<int>& nums){
        if(i == nums.size()){
            return target == 0;
        }
        if(h.find(PII(i, target)) != h.end()){
            return h[PII(i, target)];
        }
        int ans = 0;
        ans += dfs(i + 1, target - nums[i], nums);
        ans += dfs(i + 1, target + nums[i], nums);
        h[PII(i, target)] = ans;
        return ans;
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        return dfs(0, target, nums);
    }
};
```

- 473.火柴拼正方形

```c++
class Solution {
public:
    // ind:第几根火柴、arr:4个桶的容量、ms:火柴数组
    bool dfs(int ind, vector<int> &arr, vector<int> &ms){
        if(ind == -1) return true;
        for(int i = 0; i < 4; i++){
            if(arr[i] < ms[ind]) continue;
            // arr[i] > ms[ind] + ms[0]该条件是桶减去当前火柴的剩余容量还要大于等于最小的火柴，否则永远不可能拼成
            if(arr[i] == ms[ind] || arr[i] >= ms[ind] + ms[0]){
                arr[i] -= ms[ind];
                if(dfs(ind - 1, arr, ms)) return true;
                // 还需把桶长度回溯，进行下一次循环
                arr[i] += ms[ind];
            }
        }
        return false;
    }
    bool makesquare(vector<int>& matchsticks) {
        sort(matchsticks.begin(), matchsticks.end());
        vector<int> arr(4);
        int sum = 0;
        for(auto x : matchsticks) sum += x;
        if(sum % 4) return false;
        for(int i = 0; i < 4; i++) arr[i] = sum / 4;
        // 从最大的火柴开始放，倒着递归
        return dfs(matchsticks.size() - 1, arr, matchsticks);
    }
};
```

- 34.组合总和

```c++
class Solution {
public:
    // 状态：当前值ind,目标和值target
    void dfs(int ind, int target, vector<int> &nums,
        vector<int> &buff, vector<vector<int>> &ret
    ){
        if(target < 0) return ;
        if(target == 0){
            ret.push_back(buff);
            return;
        }
        if(ind == nums.size()) return ;
        dfs(ind + 1, target, nums, buff, ret);
        buff.push_back(nums[ind]);
        dfs(ind, target - nums[ind], nums, buff, ret);
        buff.pop_back();
        return ;
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> buff;
        vector<vector<int>> ret;
        dfs(0, target, candidates, buff, ret);
        return ret;
    }
};
```

- 51.N皇后

```
// 作业彩蛋中
```

# 十三.单调队列及经典问题

## 1.单调队列的基础知识

RMQ(x, y)就是询问数组[x, y]区间内部的最小值

## 2.单调队列经典题目

```c++
// oj.haizeix.com
// 271.滑动窗口
// 滑动窗口最小值
int main(){
    // n元素数量，k窗口大小
    int n, k;
    vector<int> arr;
    cin >> n >> k;
    for(int i = 0, a; i < n; i++){
        cin >> a;
        arr.push_back(a);
    }
    deque<int> q;
    for(int i = 0; i < n; i++){
        // 维护单调递增性,入队
        while(q.size() && arr[q.back()] > arr[i]) q.pop_back();
        q.push_back(i);// 编程技巧，记录原信息
        // 维护元素的生命周期，出了窗口时出队
        if(i - q.front == k) q.pop_front();
        // 没有填满窗口大小前不输出
        if(i + 1 < k) continue;
        if(i + 1 > k) count << " ";// 分隔而已，刚达到k时不需要分割
        count << arr[q.front()];
    }
    count << endl;
    // 滑动窗口最大值
    q.clear();
    for(int i = 0; i < n; i++){
        // 维护单调递减性，入队
        while(q.size() && arr[q.back()] < arr[i]) q.pop_back();
        q.push_back(i);
        // 维护元素的生命周期，出了窗口时出队
        if(i - q.front == k) q.pop_front();
        // 没有填满窗口大小前不输出
        if(i + 1 < k) continue;
        if(i + 1 > k) count << " ";
        count << arr[q.front()];
    }
    count << endl;
    return 0;
}
```

```c++
// oj.haizeix.com
// 372.双生序列
int main(){
    // n元素数量，k窗口大小
    int n;
    cin >> n;
    vector<int> a(n), b(n);
    for(int i = 0; i < n; i++) cin >> a[i];
    for(int i = 0; i < n; i++) cin >> b[i];
    deque<int> q1, q2;
    int p;
    for(p = 0; p < n; p++){
        while(q1.size() && a[p] < q1.back()) q1.pop_back();
        while(q2.size() && b[p] < q2.back()) q2.pop_back();
        q1.push_back(a[p]);
        q2.push_back(b[p]);
        if(q1.size() != q2.size()) break;
    }
    count << p << endl;
    return 0;
}
```

- 239.滑动窗口最大值

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q;
        vector<int> ret;
        for(int i = 0; i < nums.size(); i++){
            while(q.size() && nums[q.back()] < nums[i]) q.pop_back();
            q.push_back(i);
            if(i - q.front() == k) q.pop_front();
            if(i + 1 < k) continue;
            ret.push_back(nums[q.front()]);
        }
        return ret;
    }
};
```

- 剑指 Offer 59 - II. 队列的最大值

```c++
class MaxQueue {
public:
    deque<int> q, mq;
    MaxQueue() {}
    
    int max_value() {
        if(q.size() == 0) return -1;
        return mq.front();
    }
    
    void push_back(int value) {
        q.push_back(value);
        while(mq.size() && value > mq.back()) mq.pop_back();
        mq.push_back(value);
        return;
    }
    
    int pop_front() {
        if(q.size() == 0) return -1;
        if(q.front() == mq.front()) mq.pop_front();
        int ret = q.front();
        q.pop_front();
        return ret;
    }
};
```

- 862.和至少为 K 的最短子数组

```c++
class Solution {
public:
    int shortestSubarray(vector<int>& nums, int k) {
        deque<int> q;
        vector<long> sum(nums.size() + 1);
        sum[0] = 0;
        for(int i = 0; i < nums.size(); i++) sum[i + 1] = sum[i] + nums[i];
        q.push_back(0);
        int pos = -1, ans = -1;
        for(int i = 1; i < sum.size(); i++){
            while(q.size() && sum[i] - sum[q.front()] >= k){
                pos = q.front();
                q.pop_front();
            }
            if(pos != -1 && (i - pos < ans || ans == -1)) ans = i - pos;
            while(q.size() && sum[i] < sum[q.back()]) q.pop_back();
            q.push_back(i);
        }
        return ans;
    }
};
```

- 1438.绝对差不超过限制的最长连续子数组

```c++
class Solution {
public:
    // 滑动窗口为k时，是否能找到最大值和最小值小于等于limit
    bool check(vector<int> &nums, int k, int limit){
        deque<int> qmin, qmax;
        for(int i = 0; i < nums.size(); i++){
            while(qmin.size() && nums[i] < nums[qmin.back()]) qmin.pop_back();
            while(qmax.size() && nums[i] > nums[qmax.back()]) qmax.pop_back();
            qmin.push_back(i);
            qmax.push_back(i);
            if(i + 1 < k) continue;
            if(i - qmin.front() == k) qmin.pop_front();
            if(i - qmax.front() == k) qmax.pop_front();
            if(nums[qmax.front()] - nums[qmin.front()] <=limit) return true;
        }
        return false;
    }
    // 二分
    // l-2 l-1  l l+1 l+2
    //  1   1   1  0   0
    int bs(vector<int> &nums, int l, int r, int limit){
        if(l == r) return l;
        int mid = (l + r + 1) >> 1;
        if(check(nums, mid, limit)) l = mid;
        else r = mid - 1;
        return bs(nums, l, r, limit);
    }
    int longestSubarray(vector<int>& nums, int limit) {
        return bs(nums, 1, nums.size(), limit);
    }
};
```

- 513.找树左下角的值

```c++
class Solution {
public:
    int max_k, val;
    void dfs(TreeNode* root, int k){
        if(root == nullptr) return;
        if(k > max_k){
            max_k = k, val = root->val;
        }
        dfs(root->left, k + 1);
        dfs(root->right, k + 1);
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        max_k = -1, val = 0;
        dfs(root, 0);
        return val;
    }
};
```

- 135.分发糖果

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> l(ratings.size()), r(ratings.size());
        // 从左向右，初始化第一个，和前一个比
        for(int i = 0, j = 1; i < l.size(); i++){
            if(i && ratings[i] > ratings[i - 1]) j += 1;
            else j = 1;
            l[i] = j;
        }
        // 从右向左，初始化最后一个，和后一个比
        for(int i = r.size() - 1, j = 1; i >= 0; i--){
            if(i < r.size() - 1 && ratings[i] > ratings[i + 1]) j += 1;
            else j = 1;
            r[i] = j;
        }
        int ans = 0;
        for(int i = 0; i < l.size(); i++) ans += max(l[i], r[i]);
        return ans;
    }
};
```

- 365.水壶问题

```c++
class Solution {
public:
    typedef pair<int, int> PII;
    PII getNext(int k, int x, int X, int y, int Y){
        switch(k){
            // 清空第一个壶
            case 0: return PII(0, y);
            // 清空第一个壶
            case 1: return PII(x, 0);
            // 第一个壶倒入第二个壶
            case 2: {
                int delta = min(x, Y - y);
                return PII(x - delta, y + delta);
            }
            // 第二个壶倒入第一个壶
            case 3: {
                int delta = min(X - x, y);
                return PII(x + delta, y - delta);
            }
            // 第一个壶倒满
            case 4: return PII(X, y);
            // 第二个壶倒满
            case 5: return PII(x, Y);
        }
        return PII(0, 0);
    }
    struct HASH{
        long long operator()(const PII &a) const {
            return ((long long)(a.first) << 31) + a.second;
        }
    };
    bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
        unordered_set<PII, HASH> vis;
        queue<PII> q;
        vis.insert(PII(0, 0));
        q.push(PII(0, 0));
        while(!q.empty()){
            PII cur = q.front();
            if(cur.first + cur.second == targetCapacity) return true;
            q.pop();
            for(int i = 0; i < 6; i++){
                PII temp = getNext(i, cur.first, jug1Capacity, cur.second, jug2Capacity);
                if(vis.find(temp) != vis.end()) continue;
                vis.insert(temp);
                q.push(temp);
            }
        }
        return false;
    }
};
```

- 1760.袋子里最少数目的球

```c++
class Solution {
public:
    int f(vector<int>& nums, int x){
        int cnt = 0;
        for(int i = 0; i < nums.size(); i++){
            // 堆份数
            cnt += nums[i] / x + !!(nums[i] % x) - 1;
        }
        return cnt;
    }
    // 分成的堆大小
    // ... l-1  l l+1 ...
    //  0   0   1  1   1
    int bs(vector<int>& nums, int l, int r, int n){
        if(l == r) return l;
        int mid = (l + r) >> 1;
        if(f(nums, mid) <= n) r = mid;
        else l = mid + 1;
        return bs(nums, l, r, n);
    }
    int minimumSize(vector<int>& nums, int maxOperations) {
        int l = 1, r;
        for(auto x : nums) r = max(x, r);
        return bs(nums, l, r, maxOperations);
    }
};
```

- 93.复原 IP 地址

```c++
class Solution {
public:
    //k:第几个.  ind:.后的第一个合法位置
    void dfs(string &s, int k, int ind, vector<string> &ret){
        if(ind >= s.size()) return;
        if(k == 4){
            int num = 0;
            if(s.size() - ind > 1 && s[ind] == '0') return;
            for(int i = ind; i < s.size(); i++){
                num = num * 10 + s[i] - '0';
                if(num > 255) return;
            }
            ret.push_back(s);
            return;
        }
        for(int i = ind, num = 0; i < s.size(); i++){
            num = num * 10 + s[i] - '0';
            if(num > 255) return;
            if(i - ind >= 1 && s[ind] == '0') return;
            s.insert(i + 1, ".");
            dfs(s, k + 1, i + 2, ret);
            // 回溯
            s.erase(i + 1, 1);
        }
        return;
    }
    vector<string> restoreIpAddresses(string s) {
        vector<string> ret;
        dfs(s, 1, 0, ret);
        return ret;
    }
};
```

- 46.全排列

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ret;
        do{
            ret.push_back(nums);
        }while(next_permutation(nums.begin(), nums.end()));
        return ret;
    }
};
```

- 43.字符串相乘

```c++
class Solution {
public:
    string multiply(string num1, string num2) {
        vector<int> a(num1.size()), b(num2.size()), c(a.size() + b.size() - 1);
        for(int i = 0; i < num1.size(); i++) a[a.size() - i - 1] = num1[i] - '0';
        for(int i = 0; i < num2.size(); i++) b[b.size() - i - 1] = num2[i] - '0';
        for(int i = 0; i < a.size(); i++){
            for(int j = 0; j < b.size(); j++){
                // i最大a.size() - 1，j最大b.size() - 1，相加最大a.size() + b.size() - 2，所以c的长度为a.size() + b.size() - 1即可
                c[i + j] += a[i] * b[j];
            }
        }
        for(int i = 0; i < c.size(); i++){
            if(c[i] < 10) continue;
            // 最高位也需要进位
            if(i + 1 == c.size()) c.push_back(0);
            c[i + 1] += c[i] / 10;
            c[i] %= 10;
        }
        while(c.size() > 1 && c[c.size() - 1] == 0) c.pop_back();
        string ret = "";
        for(int i = c.size() - 1; i >= 0; i--) ret += c[i] + '0';
        return ret;
    }
};
```

# 十四.单调栈（Monotone-Stack）及经典问题

## 1.单调栈基础知识

不从头部出数据的单调队列，就是单调栈

绿色是蓝色女神，是蓝色前面第一个大于它的

蓝色是黄色男神，是黄色后面第一个小于它的

单调递增：最近小于关系

单调递减：最近大于关系

```c++
// 递增栈
void output(vector<int> &arr, const char *msg){
    printf("%s", msg);
    for(auto x : arr){
    	printf("%5d", x);
    }
    printf("\n");
    return;
}
int main(){
    int n;
    cin >> n;
    vector<int> arr(n);
    vector<int> pre(n), nxt(n);
    stack<int> s;
    for(int i = 0; i < n; ++i) cin >> arr[i];
    for(int i = 0; i < n; i++){
        while(s.size() && arr[i] < arr[s.top()]){
            nxt[s.top()] = i;
            s.pop();
        }
        if(s.size() == 0) pre[i] = -1;
        else pre[i] = s.top(); // 找到得是前面第一个小于等于得元素，牺牲了女神
        s.push(i);
    }
    while(s.size()) nxt[s.top()] = n, s.pop();
    output(arr, "now : ");
    output(pre, "pre : ");
    output(nxt, "nxt : ");
    return 0;
}
```

## 2.单调栈经典面试题

- 155.最小栈

```c++
class MinStack {
public:
    stack<int> s, min_s;
    MinStack() {}
    
    void push(int val) {
        s.push(val);
        if(min_s.size() == 0 || val <= min_s.top()){
            min_s.push(val);
        }
        return;
    }
    
    void pop() {
        if(s.top() == min_s.top()) min_s.pop();
        s.pop();
        return;
    }
    
    int top() {
        return s.top();
    }
    
    int getMin() {
        return min_s.top();
    }
};
```

- 503.下一个更大元素 II

```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int> s;
        vector<int> ret(nums.size());
        for(int i = 0; i < nums.size(); i++) ret[i] = -1;
        for(int i = 0; i < nums.size(); i++){
            while(s.size() && nums[i] > nums[s.top()]){
                ret[s.top()] = nums[i];
                s.pop();
            }
            s.push(i);
        }
        for(int i = 0; i < nums.size(); i++){
            while(s.size() && nums[i] > nums[s.top()]){
                ret[s.top()] = nums[i];
                s.pop();
            }
            s.push(i);
        }
        return ret;
    }
};
```

- 901.股票价格跨度

```c++
class StockSpanner {
public:
    typedef pair<int, int> PII;
    int t;
    stack<PII> s;
    StockSpanner() {
        t = 0;
        s.push(PII(INT_MAX, t++));
    }
    
    int next(int price) {
        while(s.size() && price >= s.top().first) s.pop();
        int ret = t - s.top().second;
        s.push(PII(price, t++));
        return ret;
    }
};

```

- 739.每日温度

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> ret(temperatures.size());
        stack<int> s;
        for(int i = 0; i < temperatures.size(); i++){
            while(s.size() && temperatures[i] > temperatures[s.top()]){
                ret[s.top()] = i - s.top();
                s.pop();
            }
            s.push(i);
        }
        return ret;
    }
};
```

- 84.柱状图中最大的矩形

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> s;
        vector<int> l(heights.size()), r(heights.size());
        int n = heights.size();
        for(int i = 0; i < n; i++) l[i] = -1, r[i] = n;
        for(int i = 0; i < n; i++){
            // 2 3 3 3 3 3 2
            while(s.size() && heights[i] <= heights[s.top()]){// 牺牲男神，最后一个3可以找到正确的男神女神
                r[s.top()] = i;
                s.pop();
            }
            if(s.size()) l[i] = s.top();
            s.push(i);
        }
        int ans = 0;
        for(int i = 0; i < n; i++){
            ans = max(ans, heights[i] * (r[i] - l[i] - 1));
        }
        return ans;
    }
};
```

- 1856.子数组最小乘积的最大值

```c++
class Solution {
public:
    int maxSumMinProduct(vector<int>& nums) {
        stack<int> s;
        vector<int> l(nums.size()), r(nums.size());
        int n = nums.size();
        for(int i = 0; i < n; i++) l[i] = -1, r[i] = n;
        for(int i = 0; i < n; i++){
            while(s.size() && nums[i] < nums[s.top()]){
                r[s.top()] = i;
                s.pop();
            }
            if(s.size()) l[i] = s.top();
            s.push(i);
        }
        vector<long long> sum(n + 1);
        sum[0] = 0;
        for(int i = 0; i < n; i++) sum[i + 1] = sum[i] + nums[i];
        long long ans = 0;
        for(int i = 0; i < n; i++){
            // sum的下标要大一位
            ans = max(ans, nums[i] * (sum[r[i]] - sum[l[i] + 1]));
        }
        return ans % (long long)(1e9 + 7);
    }
};
```

- 907.子数组的最小值之和

```c++
// 着实难，多看视频
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        stack<int> s;
        int mod_num = 1e9 + 7;
        long long ans = 0;
        vector<long long> sum(arr.size() + 1);
        sum[0] = 0;
        for(int i = 0; i < arr.size(); i++){
            while(s.size() && arr[i] <= arr[s.top()]) s.pop();
            int ind = s.size() ? s.top() : -1;
            s.push(i);
            // 固定i位置的S(RMQ(x,i)) = S(RMQ(x,i - 1)) + 自己贡献的和值
            sum[s.size()] = (sum[s.size() - 1] + arr[i] * (i - ind)) % mod_num;
            ans += sum[s.size()];
            ans %= mod_num;
        }
        return ans;
    }
};
```

- 496.下一个更大元素 I

```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> h;
        stack<int> s;
        for(auto x : nums2){
            while(s.size() && x > s.top()){
                h[s.top()] = x;
                s.pop();
            }
            s.push(x);
        }
        vector<int> ret(nums1.size());
        for(int i = 0; i < nums1.size(); i++){
            if(h.find(nums1[i]) == h.end()) ret[i] = -1;
            else ret[i] = h[nums1[i]];
        }
        return ret;
    }
};
```

- 456.132模式

```c++
//技巧：求数组每个元素前的最小值
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        vector<int> l(nums.size());
        l[0] = INT_MAX;
        for(int i = 1; i < nums.size(); i++) l[i] = min(l[i - 1], nums[i - 1]);
        stack<int> s;
        for(int i = nums.size() - 1; i >= 0; --i){
            // val求最后一个弹出的元素，即小于当前元素的最大值
            int val = nums[i];
            while(s.size() && nums[i] > s.top()) val = s.top(), s.pop();
            s.push(nums[i]);
            if(l[i] < nums[i] && val < nums[i] && val > l[i]) return true;
        }
        return false;
    }
};
```

- 42.接雨水

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        stack<int> s;
        for(int i = 0; i < height.size(); i++){
            while(s.size() && height[i] > height[s.top()]){
                int now = s.top();
                s.pop();
                if(s.size() == 0) continue;
                int a = height[i] - height[now];
                int b = height[s.top()] - height[now];
                ans += (i - s.top() - 1) * min(a, b);
            }
            s.push(i);
        }
        return ans;
    }
};
```

# 十五.2021.07.29 专项面试题解析

- 1367.二叉树中的列表

```c++
class Solution {
public:
    bool judge(TreeNode* root, ListNode* head) {
        if(head == nullptr) return true;
        if(root == nullptr) return false;
        if(root->val != head->val) return false;
        return judge(root->left, head->next) || judge(root->right, head->next);
    }
    bool isSubPath(ListNode* head, TreeNode* root) {
        if(head == nullptr) return true;
        if(root == nullptr) return false;
        if(root->val == head->val && judge(root, head)) return true;
        return isSubPath(head, root->left) || isSubPath(head, root->right);
    }
};
```

- 958.二叉树的完全性检验

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int nodeCount(TreeNode* root){
        if(root == nullptr) return 0;
        return nodeCount(root->left) + nodeCount(root->right) + 1;
    }
    bool judge(TreeNode* root, int n, int m){
        if(root == nullptr) return n == 0;
        if(n == 0) return false;
        if(n == 1) return root->left == nullptr && root->right == nullptr;
        int k = 2 * m - 1;
        int l = min(m, n - k), r = n - k - l;
        return judge(root->left, (k - 1) / 2 + l, m / 2) && judge(root->right, (k - 1) / 2 + r, m / 2);
    }
    bool isCompleteTree(TreeNode* root) {
        if(root == nullptr) return true;
        // m:倒数第二层的节点数量，cnt:倒数第二层上的全部数量
        int n = nodeCount(root), m = 1, cnt = 1;
        while(cnt + 2 * m <= n){
            m *= 2;
            cnt += m;
        }
        return judge(root, n, m);
    }
};
```

- 剑指 Offer 36. 二叉搜索树与双向链表

```c++
class Solution {
public:
    Node *head, *pre;
    void in_order(Node* root){
        if(root == nullptr) return;
        in_order(root->left);
        if(pre == nullptr){
            head = root;
        }else{
            pre->right = root;
        }
        root->left = pre;
        pre = root;
        in_order(root->right);
        return;
    }
    Node* treeToDoublyList(Node* root) {
        if(root == nullptr) return nullptr;
        head = pre = nullptr;
        in_order(root);
        head->left = pre;
        pre->right = head;
        return head;
    }
};
```

- 464.我能赢吗

```c++
class Solution {
public:
    // 记忆法，total是随着mask变得，
    unordered_map<int, bool> h;
    // 博弈：我赢对手输，对手赢我输
    bool dfs(int mask, int n, int total){
        if(h.find(mask) != h.end()) return h[mask];
        for(int i = 1; i <= n; i++){
            if(mask & (1 << i)) continue;
            if(i >= total || !dfs(mask | (1 << i), n, total - i)){
                return h[mask] = true;
            }
        }
        return h[mask] = false;;
    }
    bool canIWin(int maxChoosableInteger, int desiredTotal) {
        // 技巧:mask按位记录数值是否出现过
        int n = maxChoosableInteger, mask = 0;
        if((1 + n) * n / 2 < desiredTotal) return false;
        h.clear();
        return dfs(mask, maxChoosableInteger, desiredTotal);
    }
};
```

- 172.阶乘后的零

```c++
class Solution {
public:
    // 本质统计5的数量
    int trailingZeroes(int n) {
        int m = 5, cnt = 0;
        while(n / m){
            cnt += n / m;
            m *= 5;
        }
        return cnt;
    }
};
```

- 384.打乱数组

```c++
class Solution {
public:
    vector<int> nums;
    Solution(vector<int>& nums) : nums(nums) {
        // c++中想使用随机函数需要先定义随机种子
        srand(time(0));
    }
    
    vector<int> reset() {
        return nums;
    }
    
    vector<int> shuffle() {
        vector<int> ret(nums);
        for(int i = 0; i < ret.size(); i++){
            swap(ret[i], ret[rand() % ret.size()]);
        }
        return ret;
    }
};
```

- 437.路径总和 III

```c++
class Solution {
public:
    // 第一个参数前缀和，第二个参数前缀和出现的次数
    unordered_map<int, int> h;
    int count(TreeNode *root, int sum, int targetSum){
        if(root == nullptr) return 0;
        sum += root->val;
        int ans = h[sum - targetSum];
        h[sum] += 1;
        ans += count(root->left, sum, targetSum);
        ans += count(root->right, sum, targetSum);
        // 递归完自己的左右子树后，回溯哈希表
        h[sum] -= 1;
        return ans;
    }
    int pathSum(TreeNode* root, int targetSum) {
        h.clear();
        h[0] = 1;
        return count(root, 0, targetSum);
    }
};
```

- 395.至少有 K 个重复字符的最长子串

```c++
class Solution {
public:
    int longestSubstring(string s, int k) {
        unordered_map<char, int> cnt;
        vector<int> splits;
        for(auto x : s) cnt[x] += 1;
        for(int i = 0; s[i]; ++i){
            if(cnt[s[i]] < k) splits.push_back(i);
        }
        // 技巧:增加虚拟尾截断处
        splits.push_back(s.size());
        if(splits.size() == 1) return s.size();
        int pre = 0, ans = 0;
        for(auto p : splits){
            int len = p - pre;
            // >=k的时候递归，小于时得不到答案
            if(len >= k){
                ans = max(ans, longestSubstring(s.substr(pre, len), k));
            }
            pre = p + 1;
        }
        return ans;
    }
};
```

- 190.颠倒二进制位

```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t ret = 0;
        for(uint32_t i = 0, j = 1, k = (1 << 31); i < 32; i++, j <<= 1, k >>= 1){
            if(n & j) ret |= k;
        }
        return ret;
    }
};
```

- 8.字符串转换整数 (atoi)

```c++
class Solution {
public:
    int myAtoi(string s) {
        // flag：正负，max_pre：最大值除去个位，d：最大值的个位，ind：下标，num：转换后的数
        int flag = 1, max_pre = INT_MAX / 10, d = INT_MAX % 10, ind = 0, num = 0;
        while(s[ind] == ' ') ++ind;
        if(s[ind] == '-') flag = -1, ind += 1;
        else if(s[ind] == '+') ind += 1;
        for(; s[ind]; ++ind){
            if(s[ind] < '0' || s[ind] > '9') break;
            if(num > max_pre || (num == max_pre && (s[ind] - '0') > d)){
                if(flag > 0) return INT_MAX;
                return INT_MIN;
            }
            num = num * 10 + (s[ind] - '0');
        }
        return num * flag;
    }
};
```

- 380.O(1) 时间插入、删除和获取随机元素

```c++
class RandomizedSet {
public:
    unordered_map<int, int> h;
    vector<int> arr;
    RandomizedSet() {
        srand(time(0));
    }
    
    bool insert(int val) {
        if(h.find(val) != h.end()) return false;
        h[val] = arr.size();
        arr.push_back(val);
        return true;
    }
    
    void swap_item(int i, int j){
        swap(arr[i], arr[j]);
        h[arr[i]] = i;
        h[arr[j]] = j;
        return;
    }

    bool remove(int val) {
        if(h.find(val) == h.end()) return false;
        int n = h[val], m = arr.size() - 1;
        swap_item(n, m);
        h.erase(h.find(val));
        arr.pop_back();
        return true;
    }
    
    int getRandom() {
        return arr[rand() % arr.size()];
    }
};
```

- 402.移掉 K 位数字

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        if(k >= num.size()) return "0";
        string ret;
        for(auto x : num){
            while(k && ret.size() && ret.back() > x) ret.pop_back(), k -= 1;
            ret.push_back(x);
        }
        if(k != 0) ret = ret.substr(0, ret.size() - k);
        int ind = 0;
        while(ret[ind] == '0') ++ind;
        ret = ret.substr(ind, ret.size());
        if(ret == "") return "0";
        return ret;
    }
};
```

- 1081.不同字符的最小子序列
- 316.去除重复字母

```c++
class Solution {
public:
    string smallestSubsequence(string s) {
        string ret;
        // 记录每个字符出现的次数，次数为0，意味着当前循环后没有该字符，不可弹出
        unordered_map<char, int> cnt;
        for(auto x : s) cnt[x] += 1;
        // 记录栈中元素，栈中有的元素，后续不需要入栈
        unordered_set<char> h;
        for(auto x : s){
            if(h.find(x) == h.end()){
                while(ret.size() && cnt[ret.back()] && ret.back() > x){
                    h.erase(h.find(ret.back()));
                    ret.pop_back();
                }
                h.insert(x);
                ret.push_back(x);
            }
            cnt[x] -= 1;
        }
        return ret;
    }
};
```

- 1499.满足不等式的最大值

```c++
class Solution {
public:
    int findMaxValueOfEquation(vector<vector<int>>& points, int k) {
        deque<int> q;
        q.push_back(0);
        int ans = INT_MIN;
        for(int i = 1; i < points.size(); i++){
            while(q.size() && points[i][0] - points[q.front()][0] > k) q.pop_front();
            if(q.size()){
                ans = max(ans, points[i][0] - points[q.front()][0] + points[i][1] + points[q.front()][1]);
            }
            while(q.size() && points[i][1] - points[i][0] > points[q.back()][1] - points[q.back()][0]) q.pop_back();
            q.push_back(i);
        }
        return ans;
    }
};
```

# 十六.手撕 AVL 树

## 1.二叉排序树基础知识

AVL 树:平衡二叉排序树

名称：二叉排序树、二叉搜索树

性质：①左子树<根节点 ②右子树>根节点

代码实现

```c++
struct Node{
    Node(int key = 0, Node *left = nullptr, Node *right = nullptr) : key(key), left(left), right(right) {}
    int key;
    Node *left, *right;
};

Node *getNewNode(int key){
    return new Node(key);
}

Node *insert(Node *root, int key){
	if(root == nullptr) return getNewNode(key);
    if(root->key == key) return root;
    // 技巧：返回插入后的根节点，再重新赋值
    if(key < root->key) root->left = insert(root->left, key);
    else root->right = insert(root->right, key);
    return root;
}

Node *predeccessor(Node *root){
    Node *temp = root->left;
    while(temp->right) temp = temp->light;
    return temp;
}

Node *erase(Node *root, int key){
    if(root == nullptr) return root;
    if(key < root->key){
    	root->left = erase(root->left, key); 
    }else if(key > root->key){
    	root->right = erase(root->right, key);   
    }else{
        // 这段代码可以优化掉，原本度为1的逻辑也可以处理度为0的情况
        /* if(root->left == nullptr && root->right == nullptr){
            delete root;
            return nullptr;
        }else*/ if(root->left == nullptr || root->right == nullptr){
            Node *temp = root->left ? root->left : root->right;
            delete root;
            return temp;
        }else{
            Node *temp = predeccessor(root);
            root->key = temp->key;
            root->left = erase(root->left, temp->key);
        }
    }
    return root;
}

void clear(Node *root){
    if(root == nullptr) return ;
    clear(root->left);
    clear(root->right);
    delete root;
    return ;
}

void output(Node *root) {
    if (root == nullptr) return ;
    output(root->left);
    cout << root->key << " ";
    output(root->right);
    return ;
}

int main(){
    int op, val;
    Node *root = nullptr;
    while(cin >> op >> val){
        switch(op){
            case 0: root = insert(root, val); break;
            case 1: root = erase(root, val); break;
        }
        output(root); cout << endl;
    }
    return 0;
}
```

## 2.AVL树基础知识

性质:

|H(left) - H(right)| <= 1

优点：由于对每个节点的左右子树的树高做了限制，所以整棵树不会退化成一个链表

代码实现

```c++
#define NIL (&node::__NIL)

struct node {
    node(int key = 0, int h = 0, node *left = NIL, node *right = NIL) : key(key), left(left), right(right), h(h) {}
    int key, h;
    node *left, *right;
    static node __NIL;
};
// 虚拟空节点
node node::__NIL;

node *getNewNode(int key) {
    return new node(key, 1);
}

void update_height(node *root) {
    root->h = max(root->left->h, root->right->h) + 1;
    return ;
}

node *left_rotate(node *root) {
    node *new_root = root->right;
    root->right = new_root->left;
    new_root->left = root;
    update_height(root);
    update_height(new_root);
    return new_root;
}

node *right_rotate(node *root) {
    node *new_root = root->left;
    root->left = new_root->right;
    new_root->right = root;
    update_height(root);
    update_height(new_root);
    return new_root;
}

const char *TYPE_STR[5] = {"", "LL","RR","LR","RL"};

node *maintain(node *root) {
    if (abs(root->left->h - root->right->h) < 2) return root;
    int type = -1, val = root->key;
    if (root->left->h > root->right->h) {
        if (root->left->right->h > root->left->left->h) {
            // LR
            printf("%d : left rotate\n", root->left->key);
            root->left = left_rotate(root->left);
            type = 3;
    	}
        // LL
        printf("%d : right rotate\n", root->key);
        root = right_rotate(root);
        if (type == -1) type = 1;
    } else {
        if (root->right->left->h > root->right->right->h) {
            // RL
            printf("%d : right rotate\n", root->right->key);
            root->right = right_rotate(root->right);
            type = 4;
        }
        // RR
        printf("%d : left rotate\n", root->key);
        root = left_rotate(root);
        if (type == -1) type = 2;
    }
    printf("maintain type = %s\n", TYPE_STR[type]);
    return root;
}

node *insert(node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (root->key == key) return root;
    if (key < root->key) {
    	root->left = insert(root->left, key);
    } else {
        root->right = insert(root->right, key);
    }
    update_height(root);
    return maintain(root);
}

node *predeccessor(node *root) {
    node *temp = root->left;
    while (temp->right != NIL) temp = temp->right;
    return temp;
}

node *erase(node *root, int key) {
    if (root == NIL) return root;
    if (key < root->key) {
    	root->left = erase(root->left, key);
    } else if (key > root->key) {
    	root->right = erase(root->right, key);
    } else {
    	if (root->left == NIL || root->right == NIL) {
            node *temp = (root->left == NIL ? root->right : root->left);
            delete root;
            return temp;
        } else {
            node *temp = predeccessor(root);
            root->key = temp->key;
            root->left = erase(root->left, temp->key);
        }
    }
    update_height(root);
    return maintain(root);
}

void clear(node *root) {
    if (root == NIL) return ;
    clear(root->left);
    clear(root->right);
    cout << "delete : " << root->key << endl;
    delete root;
    return ;
}

void print(node *root) {
    printf("( %d[%d] | %d, %d )\n", root->key, root->h, root->left->key, root->right->key);
    return ;
}

void output(node *root) {
    if (root == NIL) return ;
    print(root);
    output(root->left);
    output(root->right);
    return ;
}

int main() {
    int op, val;
    node *root = NIL;
    while (cin >> op >> val) {
    cout << endl << "==== AVL tree print ====" << endl;
    switch (op) {
    case 0: root = insert(root, val); break;
    case 1: root = erase(root, val); break;
    }
    output(root);
    cout << "==== tree print done ====" << endl;
    }
    clear(root);
    return 0;
}

```

## 3.经典面试题

- 面试题 04.06. 后继者

```c++
class Solution {
public:
    TreeNode* pre;
    TreeNode* inorder(TreeNode *root, TreeNode *p){
        if(root == nullptr) return nullptr;
        TreeNode *node;
        if(node = inorder(root->left, p)) return node;
        if(pre == p) return root;
        pre = root;
        if(node = inorder(root->right, p)) return node;
        return nullptr;
    }
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        pre = nullptr;
        return inorder(root, p);
    }
};
```

- 450.删除二叉搜索树中的节点

```c++
class Solution {
public:
    TreeNode *predeccessor(TreeNode *root) {
    TreeNode *temp = root->left;
        while (temp->right) temp = temp->right;
        return temp;
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        if (key < root->val) {
            root->left = deleteNode(root->left, key);
        } else if (key > root->val) {
            root->right = deleteNode(root->right, key);
        } else {
            if (root->left == nullptr || root->right == nullptr) {
            TreeNode *temp = (root->left ? root->left : root->right);
                //delete root;
                return temp;
            } else {
                TreeNode *temp = predeccessor(root);
                root->val = temp->val;
                root->left = deleteNode(root->left, temp->val);
            }
        }
        return root;
    }
};
```

- 1382.二叉搜索树变平衡

```c++
class Solution {
public:
    void getNodes(TreeNode *root, vector<TreeNode *> &nodes){
        if(root == nullptr) return ;
        getNodes(root->left, nodes);
        nodes.push_back(root);
        getNodes(root->right, nodes);
        return ;
    }
    TreeNode *buildTree(vector<TreeNode *> &nodes, int l, int r){
        if(l > r) return nullptr;
        int mid = (l + r) >> 1;
        TreeNode *root = nodes[mid];
        root->left = buildTree(nodes, l, mid - 1);
        root->right = buildTree(nodes, mid + 1, r);
        return root;
    }
    TreeNode* balanceBST(TreeNode* root) {
        vector<TreeNode *> nodes;
        getNodes(root, nodes);
        return buildTree(nodes, 0, node.size() - 1);
    }
};
```

- 108.将有序数组转换为二叉搜索树

```C++
class Solution {
public:
    TreeNode *buildTree(vector<int> &nums, int l, int r) {
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        TreeNode *root = new TreeNode(nums[mid]);
        root->left = buildTree(nums, l, mid - 1);
        root->right = buildTree(nums, mid + 1, r);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return buildTree(nums, 0, nums.size() - 1);
    }
};
```

- 98.验证二叉搜索树

```c++
class Solution {
public:
    TreeNode *pre;
    bool inorder(TreeNode *root) {
        if (root == nullptr) return true;
        if (!inorder(root->left)) return false;
        if (pre != nullptr && root->val <= pre->val) {
            return false;
        }
        pre = root;
        if (!inorder(root->right)) return false;
        return true;
    }
    bool isValidBST(TreeNode* root) {
        pre = nullptr;
        return inorder(root);
    }
};
```

- 501.二叉搜索树中的众数

```c++
class Solution {
public:
    int cnt, max_cnt;
    TreeNode *now;
    void getResult(TreeNode *root, vector<int> &ret){
        if(root == nullptr) return ;
        getResult(root->left, ret);
        if(now->val == root->val){
            cnt += 1;
        }else{
            now = root;
            cnt = 1;
        }
        if(cnt == max_cnt){
            ret.push_back(now->val);
        }else if(cnt > max_cnt){
            max_cnt = cnt;
            ret.clear();
            ret.push_back(now->val);
        }
        getResult(root->right, ret);
        return ;
    }
    vector<int> findMode(TreeNode* root) {
        cnt = max_cnt = 0;
        now = root;
        vector<int> ret;
        getResult(root, ret);
        return ret;
    }
};
```

- 面试题 17.12. BiNode

```c++
class Solution {
public:
    TreeNode *head, *pre;
    void inorder(TreeNode *root) {
        if (root == nullptr) return ;
        inorder(root->left);
        if (pre == nullptr) {
            head = root;
        } else {
            pre->right = root;
        }
        // 已经使用过左子树进行递归了，所以可以直接赋值为空
        root->left = nullptr;
        pre = root;
        inorder(root->right);
        return ;
    }
    TreeNode* convertBiNode(TreeNode* root) {
        head = pre = nullptr;
        inorder(root);
        return head;
    }
};
```

<<<<<<< HEAD





















=======
- 剑指 Offer 33. 二叉搜索树的后序遍历序列

```c++
class Solution {
public:
    // 下标
    int pre;
    bool inorder(vector<int> &nums, int l, int r){
        if(l > r) return true;
        int ind = l;
        while(nums[ind] < nums[r]) ++ind;
        if(!inorder(nums, l, ind - 1)) return false;
        if(pre != -1 && nums[r] <= nums[pre]) return false;
        pre = r;
        if(!inorder(nums, ind, r - 1)) return false;
        return true;
    }
    bool verifyPostorder(vector<int>& postorder) {
        pre = -1;
        return inorder(postorder, 0, postorder.size() - 1);
    }
};
```

- 1008.前序遍历构造二叉搜索树

```c++
class Solution {
public:
    TreeNode *buildTree(vector<int> &nums, int l, int r) {
        if (l > r) return nullptr;
        int ind = l + 1;
        while (ind <= r && nums[ind] < nums[l]) ++ind;
        TreeNode *root = new TreeNode(nums[l]);
        root->left = buildTree(nums, l + 1, ind - 1);
        root->right = buildTree(nums, ind, r);
        return root;
    }
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        return buildTree(preorder, 0, preorder.size() - 1);
    }
};
```

- 面试题 04.09. 二叉搜索树序列

```c++
class Solution {
public:
    void mergeSequences(
        vector<int> &l, int lind, vector<int> &r, int rind,
        vector<int> &buff, vector<vector<int>> &ret) {
        if (lind == l.size() && rind == r.size()) {
            ret.push_back(buff);
            return ;
        }
        if (lind < l.size()) {
            buff.push_back(l[lind]);
            mergeSequences(l, lind + 1, r, rind, buff, ret);
            buff.pop_back();
        }
        if (rind < r.size()) {
            buff.push_back(r[rind]);
            mergeSequences(l, lind, r, rind + 1, buff, ret);
            buff.pop_back();
        }
        return ;
    }
    vector<vector<int>> BSTSequences(TreeNode* root) {
        vector<vector<int>> ret;
        if (root == nullptr) {
            ret.push_back(vector<int>());
            return ret;
        }
        vector<vector<int>> l_arr = BSTSequences(root->left);
        vector<vector<int>> r_arr = BSTSequences(root->right);
        for (auto l : l_arr) {
            for (auto r : r_arr) {
                vector<int> buff;
                buff.push_back(root->val);
                // l:左子树序列，0:左子树中已经选了多少元素；右同理
                mergeSequences(l, 0, r, 0, buff, ret);
            }
        }
        return ret;
    }
};
```

# 十七.手撕红黑树（上）-插入调整

## 1.基础知识

(1).红黑树的平衡条件

①每个节点非黑即红

②根节点是黑色

③叶节点(NIL)是黑色

④如果一个节点是红色，则它的两个子节点都是黑色

⑤从根节点出发到所有叶节点路径上，黑色节点数量相同

(2).问题1：红黑树中，最长路径和最短路径长度的关系？

答:根据平衡条件第4、5两点，最短路径，都是黑色，最长路径，红黑相间，最长是最短的两倍

(3).问题2：桌面理解条件3中的NIL节点

答：就像文章中的标点符号，最然它不属于内容的部分，平时你也不会注意他，可要是真没有，就会很麻烦。

(4).平衡调整终极法门

插入调整站在祖父节点看，删除调整站在父节点看，插入和删除的情况处理一共五种

(5).问题3：新插入的节点是什么颜色的？

红色，因为插入黑色一定引发失衡，插入红色不一定引发失衡，一个必死，一个有概率活，正常人，都会选后者

**调整原则：调整之前路径上黑节点数量等于调整之后黑节点数量**。

**插入调整就是为了干掉双红。**

插入调整情况一：

叔叔节点是红色

方法：父节点和叔叔节点改为黑色，祖父节点改为红色

插入调整情况二：

叔叔节点是黑色

LL型

方法：大右旋后红色上浮和下沉

LR型

方法：小左旋再LL型调整

代码演示

```c++
#define NIL &(node::__NIL)
struct node {
    node(int key = 0, int color = 0, node *lchild = NIL, node *rchild = NIL)
    : key(key), color(color), lchild(lchild), rchild(rchild) {}
    int key;
    int color; // 0 red, 1 black, 2 double black
    node *lchild, *rchild;
    static node __NIL;
};
node node::__NIL(0, 1);
node *getNewNode(int key) {
	return new node(key);
}
bool has_red_child(node *root) {
	return root->lchild->color == 0 || root->rchild->color == 0;
}
node *left_rotate(node *root) {
    node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    return temp;
}
node *right_rotate(node *root) {
    node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    return temp;
}
node *insert_maintain(node *root) {
    int flag = 0;
    if (root->lchild->color == 0 && has_red_child(root->lchild)) flag = 1;
    if (root->rchild->color == 0 && has_red_child(root->rchild)) flag = 2;
    if (flag == 0) return root;
    // 情况一
    if (root->lchild->color == 0 && root->rchild->color == 0) {
        root->color = 0;
        root->lchild->color = root->rchild->color = 1;
        return root;
    }
    // 情况二
    if (flag == 1) {
        if (root->lchild->rchild->color == 0) {
        	root->lchild = left_rotate(root->lchild);
        }
        root = right_rotate(root);
    } else {
        if (root->rchild->lchild->color == 0) {
        	root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
    // 红色上浮
    root->color = 0;
    root->lchild->color = root->rchild->color = 1;
    return root;
}
node *__insert(node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (key == root->key) return root;
    if (key < root->key) {
    	root->lchild = __insert(root->lchild, key);
    } else {
    	root->rchild = __insert(root->rchild, key);
    }
    return insert_maintain(root);
}
node *insert(node *root, int key) {
    root = __insert(root, key);
    root->color = 1;
    return root;
}
void clear(node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    delete root;
    return ;
}
void print(node *root) {
    printf("( %d | %d, %d, %d )\n",
        root->color, root->key,
        root->lchild->key, root->rchild->key
    );
    return ;
}
void output(node *root) {
    if (root == NIL) return ;
    print(root);
    output(root->lchild);
    output(root->rchild);
    return ;
}
int main() {
    int val;
    node *root = NIL;
    while (cin >> val) {
        root = insert(root, val);
        cout << endl << "==== rbtree print ====" << endl;
        output(root);
        cout << "==== rbtree print done ====" << endl;
    }
    return 0;
}
```

## 2.经典面试题

- 1339.分裂二叉树的最大乘积

```c++
class Solution {
public:
    int avg, ans = 0;
    int getTotal(TreeNode *root){
        if(root == nullptr) return 0;
        int val = root->val + getTotal(root->left) + getTotal(root->right);
        if(abs(val - avg) < abs(ans - avg)) ans = val;
        return val;
    }
    int maxProduct(TreeNode* root) {
        int total = getTotal(root);
        avg = total / 2;
        ans = total;
        getTotal(root);
        return (long long)ans * (total - ans) % (long long)(1e9+7);
    }
};
```



# 十八.手撕红黑树（下）-删除调整

## 1.删除调整的发生场景

(1).问题3：删除什么样的节点，会引发红黑树的失衡？

①删除度为0的红色节点不影响平衡

②**不可能存在度为1的红色节点，红色节点下要不没有子节点，要不有两个黑色子节点，因为需要保证每条路径黑色节点数量相同**

③**度为1的黑色节点，子节点只能是红色子节点，并且红色节点下再没有子节点，因为红色节点下要是还有黑色子节点，那么红色节点的父黑节点不可能是度为1，不然黑色数量肯定不同。**

方法：把当前节点删掉，把唯一子节点挂给父节点，子节点原来是红色，变为黑色

**总结：不可能存在度为1的节点，子节点是黑色。**

④删除度为0的黑色节点会引发失衡

方法：把NIL标记为双重黑

删除调整就是为了干掉红黑树中的双重黑

答：删除度为0的黑色节点的时候，会引发红黑树的失衡。无处安放的1个黑，导致NIL成了背锅侠。从此NIL彻底黑化。这就是双重黑的诞生过程。

(2).NIL对于删除调整很重要，解答为什么NIL节点是黑色

①.NIL节点可能挂在红色节点下

②.在删除调整中，NIL是第一个被标记为双重黑的节点

## 2.删除调整情况

情况一：双重黑节点的兄弟是黑色，并且兄弟下面没有红色节点

方法：双重节点-1层黑，父节点+1层黑，兄弟节点-1层黑

情况二：双重黑节点的兄弟是黑色，并且兄弟下面有红色节点，并且红色节点和兄弟节点是对撇的，既RR、LL

方法：RR大左旋、LL大右旋，新根节点颜色改成原根节点颜色，新根节点下两节点改成黑色，双重黑去一层黑

情况三：双重黑节点的兄弟是黑色，并且兄弟下面有红色节点，并且红色节点和兄弟节点不在同一侧，红色节点的兄弟节点是黑色、既RL、LR

为什么插入没有分开LL和LR情况呢，因为插入只需旋转不需要调整颜色

方法：先RL小右旋、LR小左旋，新根节点（红）和原根节点（黑）进行颜色互换，既原根节点改成红色，新根节点改成黑色，转化成RR、LL类型

有一点需要注意，当兄弟节点下挂着两个红色节点是情况二RR、LL类型

问题：兄弟节点为红色如何调整

兄弟红色节点要是在右边就左旋，在左边就右旋，原根节点（颜色不确定）改成红色，新根节点（原兄弟节点红）改成黑色，转化为兄弟节点为黑色的情况

代码实现

```c++
#define NIL &(node::__NIL)
struct node {
    node(int key = 0, int color = 0, node *lchild = NIL, node *rchild = NIL)
    : key(key), color(color), lchild(lchild), rchild(rchild) {}
    int key;
    int color; // 0 red, 1 black, 2 double black
    node *lchild, *rchild;
    static node __NIL;
};
node node::__NIL(0, 1);
node *getNewNode(int key) {
	return new node(key);
}
bool has_red_child(node *root) {
	return root->lchild->color == 0 || root->rchild->color == 0;
}
node *left_rotate(node *root) {
    node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    return temp;
}
node *right_rotate(node *root) {
    node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    return temp;
}
node *insert_maintain(node *root) {
    int flag = 0;
    if (root->lchild->color == 0 && has_red_child(root->lchild)) flag = 1;
    if (root->rchild->color == 0 && has_red_child(root->rchild)) flag = 2;
    if (flag == 0) return root;
    // 情况一
    if (root->lchild->color == 0 && root->rchild->color == 0) {
        root->color = 0;
        root->lchild->color = root->rchild->color = 1;
        return root;
    }
    // 情况二
    if (flag == 1) {
        if (root->lchild->rchild->color == 0) {
        	root->lchild = left_rotate(root->lchild);
        }
        root = right_rotate(root);
    } else {
        if (root->rchild->lchild->color == 0) {
        	root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
    // 红色上浮
    root->color = 0;
    root->lchild->color = root->rchild->color = 1;
    return root;
}
node *__insert(node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (key == root->key) return root;
    if (key < root->key) {
    	root->lchild = __insert(root->lchild, key);
    } else {
    	root->rchild = __insert(root->rchild, key);
    }
    return insert_maintain(root);
}
node *insert(node *root, int key) {
    root = __insert(root, key);
    root->color = 1;
    return root;
}
node *erase_maintain(node *root) {
    if (root->lchild->color != 2 && root->rchild->color != 2) return root;
    int flag = 0;
    // 判断双重黑的兄弟节点是否是黑色，如果不是转成黑色
    if (has_red_child(root)) {
        root->color = 0;
        if (root->lchild->color == 0) {
            root = right_rotate(root); flag = 1;
        } else {
            root = left_rotate(root); flag = 2;
        }
        root->color = 1;
        // 判断双重黑在哪个子树中，进行递归调整
        if (flag == 1) root->rchild = erase_maintain(root->rchild);
        else root->lchild = erase_maintain(root->lchild);
        return root;
    }
    // 情况一
    if ((root->lchild->color == 1 && !has_red_child(root->lchild))
        || (root->rchild->color == 1 && !has_red_child(root->rchild))) {
        root->lchild->color -= 1;
        root->rchild->color -= 1;
        root->color += 1;
        return root;
    }
    // 情况二三，判断黑色兄弟节点在哪里
    // L分支
    if (root->lchild->color == 1) {
        // 双重黑变正常黑
        root->rchild->color = 1;
        // LR,左子树的左子树是黑色，不是红色
        if (root->lchild->lchild->color != 0) {
            root->lchild->color = 0;
            root->lchild = left_rotate(root->lchild);
            root->lchild->color = 1;
        }
        // 新根节点颜色改成原根节点颜色
        root->lchild->color = root->color;
        root = right_rotate(root);
    // R分支，同理
    } else {
        root->lchild->color = 1;
        if (root->rchild->rchild->color != 0) {
            root->rchild->color = 0;
            root->rchild = right_rotate(root->rchild);
            root->rchild->color = 1;
        }
        root->rchild->color = root->color;
        root = left_rotate(root);
    }
    // 新根节点下两节点改成黑色
    root->lchild->color = root->rchild->color = 1;
    return root;
}

node *predecessor(node *root) {
 node *temp = root->lchild;
 while (temp->rchild != NIL) temp = temp->rchild;
 return temp;
}
node *__erase(node *root, int key) {
    if (root == NIL) return root;
    if (key < root->key) {
        root->lchild = __erase(root->lchild, key);
    } else if (key > root->key) {
        root->rchild = __erase(root->rchild, key);
    } else {
        if (root->lchild == NIL || root->rchild == NIL) {
            node *temp = root->lchild == NIL ? root->rchild : root->lchild;
            // 精髓：如果删除的是红色节点，+0对子节点没有影响
            // 如果是度为1的黑色节点，相当于把当前黑色加给了唯一子孩子，而度为1的黑色节点，唯一子孩子是红色，也就想当于把红色节点变成黑色节点
            // 如果是度为0的黑色节点，子节点是NIL，相当于把当前黑色加给NIL，变成双重黑
            temp->color += root->color;
            delete root;
            return temp;
        } else {
            node *temp = predecessor(root);
            root->key = temp->key;
            root->lchild = __erase(root->lchild, temp->key);
        }
    }
    return erase_maintain(root);
}
node *erase(node *root, int key) {
    root = __erase(root, key);
    root->color = 1;
    return root;
}

void clear(node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    delete root;
    return ;
}
void print(node *root) {
    printf("( %d | %d, %d, %d )\n",
        root->color, root->key,
        root->lchild->key, root->rchild->key
    );
    return ;
}
void output(node *root) {
    if (root == NIL) return ;
    print(root);
    output(root->lchild);
    output(root->rchild);
    return ;
}
int main() {
    int op, val;
    node *root = NIL;
    while (cin >> op >> val) {
        switch (op) {
            case 1: root = insert(root, val); break;
            case 2: root = erase(root, val); break;
        }
        cout << endl << "==== rbtree print ====" << endl;
        output(root);
        cout << "==== rbtree print done ====" << endl;
    }
    return 0;
}
```
>>>>>>> ddf241d37d4668b687ea53a5b7546ea307d27c40







































