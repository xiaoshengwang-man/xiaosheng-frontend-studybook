1.请原封不动地输出你获得的输入。

```js
let d;
while(d = readline()) {
    console.log(d);
}
```



2.假如我们的数据是其他类型，我们就需要使用对应的方法将输入的值进行类型转换

```js
let d;
while(d = readline()) {
  // 除 JSON.parse 外 Number等转换均可
  d = JSON.parse(d)
  console.log(typeof d)
}

```

3.以链表结构举例(链表为一种特殊的数据结构，其每个节点包含两个区域，数据与指针，其中指针所存储的内容为下一个节点)，本题仅需返回下一个节点即可成功

```js
let d;

function ListNode(val) {
  this.val = val;
  this.next = null;
}
function createChain(arr) {
  return arr.reduceRight((o, i) => {
    if (!(o instanceof ListNode)) {
      o = new ListNode(o)
    }

    i = new ListNode(i)
    i.next = o

    return i
  })
}

while(d = readline()) {
  d = JSON.parse(d)
  let headA = createChain(d)

  console.log(headA.next.val)
}
```

4.settime排序(不正经)

```javascript
let a = [3,2,1,6,7];
let r = [];
for(let e of a){
	settimeout(()=>{
		r.push(e)
	},e*10)
}
```

5.random排序(不正经)

```js
let a = [3,2,1,6,7];
// 打乱
function shuffle(a){
    for(let i =0;i < a.length;i++){
        let j = Math.floor(Math.random() * a.length);
        [a[i],a[j]] = [a[j],a[i]]
    }
}
// 是否是升序
function isSorted(a){
    for(let i =1;i < a.length;i++){
        if(a[i-1] > a[i]){
            return false;
        }
    }
    return true;
}
while(!isSorted(a)){shuffle(a)};
```

6.poj

7.给你一个32位的有符号(正号，负号)整数x,返回将x中的数字部分反转后的结果。

如果反转后的整数超过32为位的有符号整数的范围[-2^31,2^32-1]，就返回0

```js
let s;
while(s = readline()){
	let n = Number(s);
	let sign = n/Math.abs(n);
	let r = Number(Math.abs(n).toString().split('').reverse().join('')) * sign;
	console.log(r);
}
```

8.给定一个非空整数数组，除了某个元素只出现一次之外，其余每个元素均出现两次，找出那个只出现了一次的元素。

```js
let s;
while(s = readline()){
	let arr = JSON.parse(s);
	let r = 0;
	for(let v of arr){
		r = r ^ v
	}
	console.log(r)
}
```

9.给你一个整数x，如果x是一个回文整数，返回true；否则，返回false。

```js
let s;
while(s = readline()){
    let n = Number(s);
    if(n < 0){
        console.log(false);
    }else{
        console.log(n.toString(10).split('').reverse().join('') === 					n.toString(10))
    }
}

```

10.给定一个只包括‘(’，‘)’，‘{’，‘}’，‘[’，‘]’的字符串s，判断字符串是否有效。

有效字符串需满足：

1.左括号必须用相同类型的右括号闭合。

2.左括号必须以正确的顺序闭合。

**记住凡是左右匹配的都是用栈**

```js
let s;
while(s = readline()){
	let arr = s.split('');
    let stack = [];
    let map = {
        ")":"(",
        "}":"{",
        "]":"["
    }
    let result = true;
    for(let c of arr){
        if(c.match(/\(|\[|\{/)){
            stack.push(c);
        }else{
            if(stack[stack.length - 1] === map(c)){
                stack.pop();
            }else{
                result = false;
                break;
            }
        }
    }
    console.log(result);
}
```

1_1.选择排序

```js
const arr = readline().split(',');
console.log(selectionSort(arr).join(','))
function selectionSort(arr){
    let minIndex, temp;
    for(let i = 0; i < arr.length - 1; i++){
        minIndex = i;
        for(let j = 0; j < arr.length; j++){
            if(arr[j] < arr[minIndex]){
                minIndex = j;
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
```

1_2.插入排序

```js
const arr = readline().split(',').map(Number);
console.log(insertionSort(arr).join(','))
function insertionSort(arr){
    const len = arr.length
    let preIndex, current;
    for(let i = 1; i < len; i++){
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current){
            arr[preIndex + 1] = arr[preIndex];
            preIndex--
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}
```

1_3.插入排序

```js
const arr = readline().split(',');
console.log(sort(arr).join(','))
function sort(arr, left, rigjt){
	var len = arr.length;
    var left = left ? left : 0;
    var right = right ? right : len - 1;
    if(left < right){
        partitionIndex = partition(arr, left, right);
        sort(arr, left, partitionIndex - 1);
        sort(arr, partitionIndex + 1, right);
    }
    return arr;
}
function partition(arr, left, right){
    var privot = left; // 基准
    var index = privot + 1;
    // index不动时就是站在了大于基准值的地方，当碰到小于基准值时就交换，和75.颜色分类类似
    for(var i = index; i <= right; i++){
        if(arr[i] < arr[privot]){
            swap(arr, i, index);
            index++;
        }
    }
    swap(arr, privot, index - 1);
    return index - 1;
}
function swap(arr, i, j){
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

1_4冒泡排序

```
```



































11.题目名称：合并两个排序的链表

题目描述：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

节点构造函数如下：

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}
```

注意：本系统目前不支持链表输入和输出。所以你可能需要以下两个链表与数组的转换函数：

```js
function generateList(array){
    let fakeHead = new ListNode(0);
    let current = fakeHead;
    for(let index = 0; index < array.length; index++){
        current.next = {val:array[index],next:null};
        current = current.next;
    }
    // 这样做的好处是，不用判断是不是头节点
    return fakeHead.next;
}
function generateArray(list){
    let res = [];
    while(list){
        res.push(list.val);
        list = list.next
    }
    return res;
}
```

输入描述：[1,2,3]

[2,3,4]

输出描述：[1,2,2,3,3,4]

12.题目名称：[Web派1v1]二叉树的前序遍历

题目描述：通过readline获取输入字符串"1,,2,3"

```js
//可使用以下方法转换为二叉树结构
//const tree = convertBinaryTree(readline().split(','));
function convertBinaryTree(arr){
    let root;
    let insertNode = function(parentNode, childNode){
        if(childNode.val < parentNode.val){
            if (parentNode.left === null) parentNode.left = childNode;
            else insertNode(parentNode.left, childNode);
        }else {
            if (parentNode.right === null) parentNode.right = childNode;
            else insertNode(parentNode.right, childNode);
        }
    }
    arr.forEach(val => {
        let node ={
            val:val,
            left:null,
            right:null
        }
        if(root) insertNode(root,node);
        else root = node;
    })
    return root;
}

```

输入描述：给你1,,2,3

输出描述：输出1,2,3

13.题目描述：使用“计数排序”将输入的数组排序

输入描述：输入一个数组，比如：[2,3,8,7,1,2,2,8,9]

输出描述：输出排序后的数组的字符串形式，比如：1,2,,2,2,3,7,8,8,9

14.
